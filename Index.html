<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pixel Pitch Pro - Mobile Joystick & Render Debug</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        :root {
            --primary-accent: #00AEEF; 
            --secondary-accent: #FFD700; 
            
            --player1-jersey: #D00000; 
            --player1-shorts: #202020; 
            --player1-trim: #FFFFFF; /* Head color for P1 */
            --gk1-jersey: #FF8C00; 

            --player2-jersey: #0057B7; 
            --player2-shorts: #FFFFFF; 
            --player2-trim: #FFD700; /* Head color for P2 */
            --gk2-jersey: #32CD32;   
            
            --ball-color: #FFFFFF; 
            --ball-panel-color: #1E1E1E; 
            --background-dark: #102018; 
            --pitch-grass-light: #4CAF50; 
            --pitch-grass-dark: #388E3C;  
            --pitch-line-color: rgba(255, 255, 255, 0.85); 
            --goal-post-color: #E0E0E0; 
            --goal-net-color: rgba(200, 200, 200, 0.4); 
            
            --ui-panel-bg: rgba(28, 28, 32, 0.9); 
            --text-light: #F5F5F5;
            --text-dark: #121212; 
            --text-secondary: #A0A0A0; 

            --joystick-base-bg: rgba(50, 50, 55, 0.7);  
            --joystick-nub-bg: var(--primary-accent);
            --joystick-nub-border: rgba(255, 255, 255, 0.9);
            
            --action-button-bg: var(--primary-accent);
            --action-button-text: #FFFFFF;
            --action-button-active-bg: #008ECC; 
            
            --gemini-button-bg: var(--secondary-accent);
            --gemini-button-text: #121212;
            --gemini-button-border: #DAA520; 
            --shadow-color: rgba(0, 0, 0, 0.35);

            --stadium-stand-color-1: #37474F; 
            --stadium-stand-color-2: #455A64; 
        }

        html, body {
            height: 100%;
            overflow: hidden;
            background-color: var(--background-dark);
            font-family: 'Inter', sans-serif;
            color: var(--text-light);
        }

        body {
            margin: 0;
            padding: 0;
            display: flex; 
            justify-content: center;
            align-items: center;
        }

        #gameWrapper {
            width: 100%;
            height: 100%;
            position: relative; 
            background-color: var(--background-dark); 
        }
        
        #gameContainer {
            width: 100%;
            height: 100%;
            position: absolute; 
            top: 0;
            left: 0;
            overflow: hidden; 
            z-index: 1; 
            cursor: default; 
        }

        #uiContainer {
            position: absolute; 
            top: 10px; left: 50%; transform: translateX(-50%);
            padding: 8px 15px; background-color: var(--ui-panel-bg); border-radius: 12px; 
            z-index: 100; display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;
            align-items: center; box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        .ui-button { font-family: 'Inter', sans-serif; font-weight: 600; background-color: var(--primary-accent); border: none; color: var(--text-light); padding: 8px 15px; font-size: clamp(12px, 2vw, 14px); cursor: pointer; border-radius: 8px; text-shadow: none; transition: background-color 0.2s, transform 0.1s; }
        .ui-button:hover:not(:disabled) { background-color: var(--action-button-active-bg); transform: translateY(-1px); }
        .ui-button:disabled { background-color: #444; color: #888; cursor: not-allowed; }
        .gemini-button { background-color: var(--gemini-button-bg); color: var(--gemini-button-text); }
        .gemini-button:hover:not(:disabled) { background-color: var(--gemini-button-border); }
        .gemini-button:disabled { background-color: #756633; }

        .score, #timerDisplay { font-size: clamp(16px, 3vw, 20px); font-weight: 700; color: var(--text-light); text-shadow: 1px 1px 3px rgba(0,0,0,0.5); padding: 5px 10px; background-color: rgba(0,0,0,0.2); border-radius: 6px; }
        #player1Score { color: var(--player1-jersey); border: 1px solid var(--player1-jersey); }
        #player2Score { color: var(--player2-jersey); border: 1px solid var(--player2-jersey); }
        #timerDisplay { color: var(--primary-accent); border: 1px solid var(--primary-accent); }

        #banterDisplay { position: absolute; top: calc(10px + 70px); left: 50%; transform: translateX(-50%); width: auto; max-width: 80%; padding: 8px 15px; box-sizing: border-box; background-color: rgba(30, 30, 35, 0.85); border-radius: 8px; border: 1px solid var(--primary-accent); color: var(--text-light); font-size: clamp(12px, 2.5vw, 15px); font-weight: 400; text-align: center; margin-top: 8px; min-height: 25px; display: none; text-shadow: 1px 1px 2px rgba(0,0,0,0.3); z-index: 99; }
        #messageDisplay { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(1); font-size: clamp(20px, 5vw, 32px); font-weight: 700; color: var(--text-light); text-shadow: 0 0 10px var(--secondary-accent), 2px 2px 5px #000; padding: 18px 25px; background: linear-gradient(145deg, rgba(40,40,45,0.95), rgba(20,20,25,0.95)); border: 2px solid var(--secondary-accent); border-radius: 15px; text-align: center; z-index: 110; display: none; opacity: 0; max-width: 85%; box-shadow: 0 5px 25px rgba(0,0,0,0.5); transition: transform 0.15s ease-out, opacity 0.15s ease-out; }
        #messageDisplay.show { display: block; opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
        #messageDisplay.hide { opacity: 0; transform: translate(-50%, -50%) scale(0.95); }
        #messageDisplay.goal-celebration { animation: goalPulseModern 0.6s ease-out forwards; }
        @keyframes goalPulseModern { 0% { transform: translate(-50%, -50%) scale(1); opacity: 1;} 50% { transform: translate(-50%, -50%) scale(1.15); opacity: 0.85;} 100% { transform: translate(-50%, -50%) scale(1); opacity: 1;} }
        
        #controlsInfo { position: absolute; bottom: 15px; left: 50%; transform: translateX(-50%); font-size: clamp(11px, 1.8vw, 13px); color: var(--text-secondary); text-align: center; z-index: 100; }
        #controlsInfo p { margin: 4px 0; }

        #touchControlsContainer { position: fixed; bottom: clamp(25px, 8vh, 60px); left: 0; width: 100%; padding: 0 clamp(15px, 4vw, 25px); box-sizing: border-box; display: none; justify-content: space-between; align-items: flex-end; z-index: 105; pointer-events: none; }
        .touch-control-area { display: flex; align-items: center; justify-content: center; pointer-events: auto; }
        #joystickArea { width: clamp(120px, 24vmin, 170px); height: clamp(120px, 24vmin, 170px); position: relative; opacity: 0.9; }
        #joystickBase { width: 100%; height: 100%; background-color: var(--joystick-base-bg); border-radius: 50%; border: 2px solid rgba(255,255,255,0.2); box-shadow: 0 0 12px rgba(0,0,0,0.3) inset; }
        #joystickNub { width: clamp(50px, 10vmin, 70px); height: clamp(50px, 10vmin, 70px); background-color: var(--joystick-nub-bg); border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); border: 2px solid var(--joystick-nub-border); box-shadow: 0 0 15px var(--joystick-nub-bg); }
        #actionButtonsArea { display: flex; flex-direction: column; align-items: center; }
        .action-button { width: clamp(75px, 17vmin, 95px); height: clamp(75px, 17vmin, 95px); background-color: var(--action-button-bg) ; border: none; box-shadow: 0 3px 8px rgba(0,0,0,0.4); border-radius: 50%; display: flex; align-items: center; justify-content: center; color: var(--action-button-text); font-family: 'Inter', sans-serif; font-weight: 600; font-size: clamp(11px, 2.5vmin, 14px); text-align: center; opacity: 0.95; margin: 8px; user-select: none; pointer-events: auto; transition: background-color 0.1s ease-out, transform 0.05s ease-out, box-shadow 0.1s ease-out; }
        .action-button.active, .action-button:active { 
            background-color: var(--action-button-active-bg); 
            transform: scale(0.92); 
            box-shadow: 0 1px 4px rgba(0,0,0,0.3); 
        }

    </style>
</head>
<body>
    <div id="gameWrapper">
        <div id="uiContainer">
            <div id="player1Score" class="score">P1: 0</div>
            <div id="timerDisplay" class="score">Time: 90</div>
            <button id="muteButton" class="ui-button">Mute</button>
            <button id="teamNameButton" class="ui-button gemini-button">✨ Names</button>
            <button id="banterButton" class="ui-button gemini-button">✨ Banter</button>
            <div id="player2Score" class="score">P2: 0</div>
        </div>
        <div id="banterDisplay"></div> 
        
        <div id="gameContainer"></div>

        <div id="messageDisplay">Message</div>
        <div id="controlsInfo">
             <p>P1: Arrows/WASD, Space to Kick/Sprint. Q/E for Aftertouch (during kick).</p>
             <p>Enter to Start/Restart</p>
        </div>
    </div>

    <div id="touchControlsContainer"> 
        <div id="joystickArea" class="touch-control-area">
            <div id="joystickBase"></div>
            <div id="joystickNub"></div>
        </div>
        <div id="actionButtonsArea" class="touch-control-area">
            <button id="kickButton" class="action-button">KICK</button>
            </div>
    </div>

    <script>
        console.log("Script execution started - Pixel Pitch Pro - Mobile Joystick & Render Debug.");

        // --- Three.js Scene Variables ---
        let scene, camera, renderer; 
        let pitchMesh;
        const PITCH_LENGTH_METERS = 105; 
        const PITCH_WIDTH_METERS = 68;   
        const METER_TO_3D_UNIT = 0.4; 
        const PITCH_LENGTH_3D = PITCH_LENGTH_METERS * METER_TO_3D_UNIT; 
        const PITCH_WIDTH_3D = PITCH_WIDTH_METERS * METER_TO_3D_UNIT;   

        const PLAYER_SCALE_FACTOR = 0.8; 
        const PLAYER_BODY_RADIUS_TOP_3D = (0.25 * PLAYER_SCALE_FACTOR) * METER_TO_3D_UNIT; 
        const PLAYER_BODY_RADIUS_BOTTOM_3D = (0.30 * PLAYER_SCALE_FACTOR) * METER_TO_3D_UNIT; 
        const PLAYER_BODY_HEIGHT_3D = (0.8 * PLAYER_SCALE_FACTOR) * METER_TO_3D_UNIT;  
        const PLAYER_HEAD_RADIUS_3D = (0.20 * PLAYER_SCALE_FACTOR) * METER_TO_3D_UNIT; 
        const PLAYER_Y_OFFSET = PLAYER_BODY_HEIGHT_3D / 2; 
        
        const BALL_RADIUS_METERS = 0.11; 
        const BALL_RADIUS_3D = BALL_RADIUS_METERS * METER_TO_3D_UNIT * 3; 
        
        const GOAL_WIDTH_METERS = 7.32;
        const GOAL_HEIGHT_METERS = 2.44;
        const GOAL_WIDTH_3D = GOAL_WIDTH_METERS * METER_TO_3D_UNIT; 
        const GOAL_HEIGHT_3D = GOAL_HEIGHT_METERS * METER_TO_3D_UNIT; 
        const GOAL_DEPTH_3D = 2.0 * METER_TO_3D_UNIT; 
        const GOAL_POST_RADIUS = 0.06 * METER_TO_3D_UNIT; 

        const gameMeshes = { player1: null, player2: null, gk1: null, gk2: null, ball: null, goal1: null, goal2: null };
        let ballPhysics = {
            velocity: new THREE.Vector3(0, 0, 0),
            friction: 0.975, 
            controlledBy: null 
        };

        // --- DOM Elements ---
        const banterDisplay = document.getElementById('banterDisplay');
        const teamNameButton = document.getElementById('teamNameButton');
        const banterButton = document.getElementById('banterButton');
        const muteButton = document.getElementById('muteButton');
        const player1ScoreDisplay = document.getElementById('player1Score');
        const player2ScoreDisplay = document.getElementById('player2Score');
        const timerDisplay = document.getElementById('timerDisplay');
        const messageDisplay = document.getElementById('messageDisplay');
        const touchControlsContainer = document.getElementById('touchControlsContainer');
        const kickButton = document.getElementById('kickButton'); 
        const gameContainer = document.getElementById('gameContainer');
        let joystickArea, joystickNub; // Declare here, assign in initGame or initControls

        // --- Gemini API ---
        let apiCallCount = 0; 
        const MAX_API_CALLS_PER_GAME = 10; 
        let geminiFeaturesDisabled = false; 

        // --- Audio ---
        let isMuted = false;
        let audioInitialized = false;
        const soundEffects = {};
        const soundDebounceTimes = {}; 
        const DEBOUNCE_THRESHOLD_MS = 50; 

        // --- Game State Variables ---
        const PLAYER_NORMAL_SPEED = 7 * METER_TO_3D_UNIT;
        const PLAYER_SPRINT_SPEED = 11 * METER_TO_3D_UNIT;
        const SPRINT_DURATION = 1.5; 
        const KICK_RANGE_MULTIPLIER = 1.5; 

        let g_player1 = { 
            score: 0, teamName: "Player 1", mesh: null, 
            currentSpeed: PLAYER_NORMAL_SPEED, 
            isSprinting: false, sprintTimer: 0,
            hasBall: false, kickProcessedThisFrame: false
        }; 
        let g_player2 = { score: 0, teamName: "Player 2", mesh: null }; 
        let g_gk1 = { mesh: null };
        let g_gk2 = { mesh: null };
        let g_ball = { mesh: null };

        let timeLeft = 90; 
        let gameLoopId; 
        let isGameRunning = false;
        let gamePaused = false; 

        // --- Input State ---
        let isJoystickActive = false;
        let joystickInput = { x: 0, y: 0 };
        let keyboardInput = { forward: 0, back: 0, left: 0, right: 0, kick: false };


        // --- Initialization ---
        window.onload = initGame; 

        function initGame() {
            console.log("Initializing game...");
            // Assign joystick DOM elements here, after DOM is loaded
            joystickArea = document.getElementById('joystickArea'); 
            joystickNub = document.getElementById('joystickNub');   
            if (!joystickArea || !joystickNub) {
                console.error("CRITICAL: JoystickArea or JoystickNub not found in DOM!");
            }


            setupScene(); 
            createPlayers(); 
            createGoals();
            createBall();
            resetForKickOff(true); 
            
            updateCamera(0); 
            
            resetGeminiUsage();
            initControls(); // Joystick listeners are set up here
            updateScores(); 
            updateTimerDisplay(); 

            if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                if(touchControlsContainer) touchControlsContainer.style.display = 'flex';
                 console.log("Touch controls should be visible.");
            } else {
                console.log("Not a touch device, or touch detection failed.");
            }
            
            showMessage("Press Enter to Start", false); 
            console.log("Game initialized. Waiting for user to start.");

            if (renderer && scene && camera) {
                console.log("Game Container Dimensions:", gameContainer.clientWidth, "x", gameContainer.clientHeight);
                console.log("Renderer DOM Element (Canvas) Dimensions:", renderer.domElement.width, "x", renderer.domElement.height);
                renderer.render(scene, camera);
                console.log("Initial scene rendered.");
            } else {
                console.error("Renderer, scene, or camera not initialized for initial render.");
            }
        }

        function startGame() {
            console.log("Starting game...");
            if (!audioInitialized) {
                initAudio().then(() => { 
                     playSoundEffect('whistleShort'); 
                });
            } else {
                 playSoundEffect('whistleShort');
            }
            
            isGameRunning = true;
            gamePaused = false;
            resetGeminiUsage(); 
            timeLeft = 90; 
            
            resetForKickOff(true); 

            updateScores();
            updateTimerDisplay();
            hideMessage();
            
            if (gameLoopId) cancelAnimationFrame(gameLoopId); 
            lastTime = performance.now(); 
            animate(); 
            console.log("Game started and animation loop running.");
        }
        
        function setupScene() {
            // ... (setupScene logic - unchanged)
            console.log("Setting up scene...");
            scene = new THREE.Scene();
            scene.background = new THREE.Color(getComputedStyle(document.documentElement).getPropertyValue('--background-dark').trim());
            scene.fog = new THREE.Fog(scene.background, PITCH_LENGTH_3D * 1.2, PITCH_LENGTH_3D * 3.0); 

            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(50, aspect, 0.1, PITCH_LENGTH_3D * 5); 
            
            camera.position.set(0, PITCH_WIDTH_3D * 0.8, PITCH_LENGTH_3D * 0.75); 
            camera.lookAt(0, 0, 0); 
            scene.add(camera);
            // console.log("Initial camera position set:", camera.position);


            const ambientLight = new THREE.AmbientLight(0xffffff, 0.9); 
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.1); 
            directionalLight.position.set(PITCH_WIDTH_3D * 0.6, PITCH_LENGTH_3D * 0.8, PITCH_LENGTH_3D * 0.6);
            directionalLight.castShadow = true; 
            directionalLight.shadow.mapSize.width = 2048; 
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = PITCH_LENGTH_3D * 0.05; 
            directionalLight.shadow.camera.far = PITCH_LENGTH_3D * 3;
            directionalLight.shadow.camera.left = -PITCH_WIDTH_3D * 1.5;
            directionalLight.shadow.camera.right = PITCH_WIDTH_3D * 1.5;
            directionalLight.shadow.camera.top = PITCH_LENGTH_3D * 1.5;
            directionalLight.shadow.camera.bottom = -PITCH_LENGTH_3D * 1.5;
            scene.add(directionalLight);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; 
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            if (gameContainer) {
                 gameContainer.appendChild(renderer.domElement);
            } else {
                console.error("gameContainer not found for renderer!");
            }
            
            drawPitchMarkings(); 
            createStadium();

            console.log("Scene setup complete.");
            window.addEventListener('resize', onWindowResize, false);
        }

        function drawPitchMarkings() {
            // ... (drawPitchMarkings logic - unchanged)
            const canvas = document.createElement('canvas');
            const textureWidth = 1024; 
            const textureHeight = Math.round(textureWidth * (PITCH_LENGTH_METERS / PITCH_WIDTH_METERS));
            canvas.width = textureWidth;
            canvas.height = textureHeight;
            const context = canvas.getContext('2d');

            context.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--pitch-grass-light').trim();
            context.fillRect(0, 0, canvas.width, canvas.height);

            const lineColor = getComputedStyle(document.documentElement).getPropertyValue('--pitch-line-color').trim();
            const lineWidthPixels = 4; 
            context.strokeStyle = lineColor;
            context.lineWidth = lineWidthPixels;

            const m2px_w = (val) => (val / PITCH_WIDTH_METERS) * textureWidth;
            const m2px_l = (val) => (val / PITCH_LENGTH_METERS) * textureHeight;
            
            context.strokeRect(lineWidthPixels / 2, lineWidthPixels / 2, textureWidth - lineWidthPixels, textureHeight - lineWidthPixels);

            context.beginPath();
            context.moveTo(lineWidthPixels / 2, textureHeight / 2);
            context.lineTo(textureWidth - lineWidthPixels / 2, textureHeight / 2);
            context.stroke();

            const centerCircleRadiusMeters = 9.15;
            context.beginPath();
            context.arc(textureWidth / 2, textureHeight / 2, m2px_w(centerCircleRadiusMeters), 0, 2 * Math.PI);
            context.stroke();
            context.beginPath();
            context.arc(textureWidth / 2, textureHeight / 2, m2px_w(0.15), 0, 2 * Math.PI); 
            context.fillStyle = lineColor;
            context.fill();

            const penaltyAreaWidthMeters = 40.32; 
            const penaltyAreaLengthMeters = 16.5;
            const goalAreaWidthMeters = 18.32; 
            const goalAreaLengthMeters = 5.5;
            const penaltySpotDistMeters = 11;
            const penaltyArcRadiusMeters = 9.15;

            function drawHalfMarkings(isTopHalf) {
                const halfSign = isTopHalf ? 1 : -1;
                const L_origin = isTopHalf ? 0 : textureHeight; 
                const L_penaltyAreaEdge = L_origin + halfSign * m2px_l(penaltyAreaLengthMeters);
                const L_goalAreaEdge = L_origin + halfSign * m2px_l(goalAreaLengthMeters);
                const L_penaltySpot = L_origin + halfSign * m2px_l(penaltySpotDistMeters);

                context.strokeRect(
                    (textureWidth - m2px_w(penaltyAreaWidthMeters)) / 2,
                    isTopHalf ? lineWidthPixels / 2 : L_penaltyAreaEdge,
                    m2px_w(penaltyAreaWidthMeters),
                    m2px_l(penaltyAreaLengthMeters)
                );

                context.strokeRect(
                    (textureWidth - m2px_w(goalAreaWidthMeters)) / 2,
                     isTopHalf ? lineWidthPixels / 2 : L_goalAreaEdge,
                    m2px_w(goalAreaWidthMeters),
                    m2px_l(goalAreaLengthMeters)
                );
                
                context.beginPath();
                context.arc(textureWidth / 2, L_penaltySpot, m2px_w(0.15), 0, 2 * Math.PI);
                context.fillStyle = lineColor;
                context.fill();
                context.strokeStyle = lineColor; 

                context.beginPath();
                const arcAngle = Math.acos((penaltyAreaLengthMeters - penaltySpotDistMeters) / penaltyArcRadiusMeters); 
                if (isTopHalf) {
                     context.arc(textureWidth / 2, L_penaltySpot, m2px_w(penaltyArcRadiusMeters), Math.PI/2 - arcAngle, Math.PI/2 + arcAngle);
                } else {
                     context.arc(textureWidth / 2, L_penaltySpot, m2px_w(penaltyArcRadiusMeters), -Math.PI/2 - arcAngle, -Math.PI/2 + arcAngle, true);
                }
                context.stroke();
            }

            drawHalfMarkings(true); 
            drawHalfMarkings(false); 
            
            const cornerArcRadiusMeters = 1.0;
            const cornerRadiusPx = m2px_w(cornerArcRadiusMeters);
            context.beginPath(); 
            context.arc(lineWidthPixels/2, lineWidthPixels/2, cornerRadiusPx, 0, Math.PI / 2); context.stroke();
            context.beginPath(); 
            context.arc(textureWidth - lineWidthPixels/2, lineWidthPixels/2, cornerRadiusPx, Math.PI / 2, Math.PI); context.stroke();
            context.beginPath(); 
            context.arc(lineWidthPixels/2, textureHeight - lineWidthPixels/2, cornerRadiusPx, 3 * Math.PI / 2, 2 * Math.PI); context.stroke();
            context.beginPath(); 
            context.arc(textureWidth - lineWidthPixels/2, textureHeight - lineWidthPixels/2, cornerRadiusPx, Math.PI, 3 * Math.PI / 2); context.stroke();

            const pitchTexture = new THREE.CanvasTexture(canvas);
            const pitchMaterial = new THREE.MeshLambertMaterial({ map: pitchTexture });
            const pitchGeometry = new THREE.PlaneGeometry(PITCH_WIDTH_3D, PITCH_LENGTH_3D);
            pitchMesh = new THREE.Mesh(pitchGeometry, pitchMaterial);
            pitchMesh.rotation.x = -Math.PI / 2;
            pitchMesh.receiveShadow = true;
            scene.add(pitchMesh);
        }

        function createStadium() {
            // ... (createStadium logic - unchanged)
            const standHeight = PITCH_WIDTH_3D * 0.3;
            const standDepth = PITCH_WIDTH_3D * 0.5;
            const standMaterial1 = new THREE.MeshLambertMaterial({ color: getComputedStyle(document.documentElement).getPropertyValue('--stadium-stand-color-1').trim() });
            const standMaterial2 = new THREE.MeshLambertMaterial({ color: getComputedStyle(document.documentElement).getPropertyValue('--stadium-stand-color-2').trim() });

            const sideStandGeo = new THREE.BoxGeometry(standDepth, standHeight, PITCH_LENGTH_3D + standDepth * 0.5); 
            
            const standLeft = new THREE.Mesh(sideStandGeo, standMaterial1);
            standLeft.position.set(-(PITCH_WIDTH_3D / 2 + standDepth / 2), standHeight / 2, 0);
            standLeft.receiveShadow = true;
            scene.add(standLeft);

            const standRight = new THREE.Mesh(sideStandGeo, standMaterial1);
            standRight.position.set(PITCH_WIDTH_3D / 2 + standDepth / 2, standHeight / 2, 0);
            standRight.receiveShadow = true;
            scene.add(standRight);
            
            const endStandGeo = new THREE.BoxGeometry(PITCH_WIDTH_3D + standDepth * 0.5, standHeight, standDepth);
            
            const standTop = new THREE.Mesh(endStandGeo, standMaterial2);
            standTop.position.set(0, standHeight/2, -(PITCH_LENGTH_3D / 2 + standDepth / 2));
            standTop.receiveShadow = true;
            scene.add(standTop);

            const standBottom = new THREE.Mesh(endStandGeo, standMaterial2);
            standBottom.position.set(0, standHeight/2, PITCH_LENGTH_3D / 2 + standDepth / 2);
            standBottom.receiveShadow = true;
            scene.add(standBottom);
        }


        function onWindowResize() {
            // ... (onWindowResize logic - unchanged)
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                console.log("Window resized.");
            }
        }

        function createPlayerMesh(jerseyColorHex, shortsColorHex, trimColorHex) {
            // ... (createPlayerMesh logic - unchanged)
            const group = new THREE.Group();
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: jerseyColorHex });
            const bodyGeometry = new THREE.CylinderGeometry(PLAYER_BODY_RADIUS_TOP_3D, PLAYER_BODY_RADIUS_BOTTOM_3D, PLAYER_BODY_HEIGHT_3D, 16);
            const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
            bodyMesh.castShadow = true;
            bodyMesh.receiveShadow = true; 
            group.add(bodyMesh);

            const headMaterial = new THREE.MeshLambertMaterial({ color: trimColorHex }); 
            const headGeometry = new THREE.SphereGeometry(PLAYER_HEAD_RADIUS_3D, 16, 16);
            const headMesh = new THREE.Mesh(headGeometry, headMaterial);
            headMesh.position.y = PLAYER_BODY_HEIGHT_3D / 2 + PLAYER_HEAD_RADIUS_3D * 0.8; 
            headMesh.castShadow = true;
            headMesh.receiveShadow = true;
            group.add(headMesh);
            
            return group;
        }

        function createPlayers() {
            // ... (createPlayers logic - unchanged)
            const p1Color = getComputedStyle(document.documentElement).getPropertyValue('--player1-jersey').trim();
            const p1Shorts = getComputedStyle(document.documentElement).getPropertyValue('--player1-shorts').trim();
            const p1Trim = getComputedStyle(document.documentElement).getPropertyValue('--player1-trim').trim();
            
            const p2Color = getComputedStyle(document.documentElement).getPropertyValue('--player2-jersey').trim();
            const p2Shorts = getComputedStyle(document.documentElement).getPropertyValue('--player2-shorts').trim();
            const p2Trim = getComputedStyle(document.documentElement).getPropertyValue('--player2-trim').trim();

            const gk1Color = getComputedStyle(document.documentElement).getPropertyValue('--gk1-jersey').trim();
            const gk2Color = getComputedStyle(document.documentElement).getPropertyValue('--gk2-jersey').trim();

            gameMeshes.player1 = createPlayerMesh(p1Color, p1Shorts, p1Trim);
            g_player1.mesh = gameMeshes.player1;
            scene.add(gameMeshes.player1);

            gameMeshes.player2 = createPlayerMesh(p2Color, p2Shorts, p2Trim);
            g_player2.mesh = gameMeshes.player2;
            scene.add(gameMeshes.player2);

            gameMeshes.gk1 = createPlayerMesh(gk1Color, p1Shorts, p1Trim); 
            g_gk1.mesh = gameMeshes.gk1;
            scene.add(gameMeshes.gk1);

            gameMeshes.gk2 = createPlayerMesh(gk2Color, p2Shorts, p2Trim); 
            g_gk2.mesh = gameMeshes.gk2;
            scene.add(gameMeshes.gk2);
            // console.log("Players created.");
        }

        function createGoalMesh() {
            // ... (createGoalMesh logic - unchanged)
            const group = new THREE.Group();
            const postMaterial = new THREE.MeshLambertMaterial({ color: getComputedStyle(document.documentElement).getPropertyValue('--goal-post-color').trim() });
            const postGeo = new THREE.CylinderGeometry(GOAL_POST_RADIUS, GOAL_POST_RADIUS, GOAL_HEIGHT_3D, 12);

            const leftPost = new THREE.Mesh(postGeo, postMaterial);
            leftPost.position.set(-GOAL_WIDTH_3D / 2, GOAL_HEIGHT_3D / 2, 0);
            leftPost.castShadow = true;
            group.add(leftPost);

            const rightPost = new THREE.Mesh(postGeo, postMaterial);
            rightPost.position.set(GOAL_WIDTH_3D / 2, GOAL_HEIGHT_3D / 2, 0);
            rightPost.castShadow = true;
            group.add(rightPost);

            const crossbarGeo = new THREE.CylinderGeometry(GOAL_POST_RADIUS, GOAL_POST_RADIUS, GOAL_WIDTH_3D, 12);
            const crossbar = new THREE.Mesh(crossbarGeo, postMaterial);
            crossbar.rotation.z = Math.PI / 2;
            crossbar.position.set(0, GOAL_HEIGHT_3D, 0);
            crossbar.castShadow = true;
            group.add(crossbar);

            const netMaterial = new THREE.MeshBasicMaterial({ 
                color: getComputedStyle(document.documentElement).getPropertyValue('--goal-net-color').trim(), 
                side: THREE.DoubleSide, 
                transparent: true, 
                opacity: 0.5 
            });
            const backNetGeo = new THREE.PlaneGeometry(GOAL_WIDTH_3D, GOAL_HEIGHT_3D);
            const backNet = new THREE.Mesh(backNetGeo, netMaterial);
            backNet.position.set(0, GOAL_HEIGHT_3D / 2, -GOAL_DEPTH_3D / 2); 
            group.add(backNet);
            
            return group;
        }

        function createGoals() {
            // ... (createGoals logic - unchanged)
            gameMeshes.goal1 = createGoalMesh(); 
            gameMeshes.goal1.position.z = PITCH_LENGTH_3D / 2;
            scene.add(gameMeshes.goal1);

            gameMeshes.goal2 = createGoalMesh(); 
            gameMeshes.goal2.position.z = -PITCH_LENGTH_3D / 2;
            gameMeshes.goal2.rotation.y = Math.PI; 
            scene.add(gameMeshes.goal2);
            // console.log("Goals created.");
        }

        function createBallMesh() {
            // ... (createBallMesh logic - unchanged)
            const ballMaterial = new THREE.MeshLambertMaterial({ color: getComputedStyle(document.documentElement).getPropertyValue('--ball-color').trim() });
            const ballGeometry = new THREE.SphereGeometry(BALL_RADIUS_3D, 16, 16);
            const ballMesh = new THREE.Mesh(ballGeometry, ballMaterial);
            ballMesh.castShadow = true;
            ballMesh.receiveShadow = true; 
            return ballMesh;
        }
        
        function createBall() {
            // ... (createBall logic - unchanged)
            gameMeshes.ball = createBallMesh();
            g_ball.mesh = gameMeshes.ball;
            scene.add(gameMeshes.ball);
            // console.log("Ball created.");
        }


        function initControls() {
            console.log("Initializing controls...");
            // Keyboard controls (remains the same)
            document.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    if (!isGameRunning) startGame();
                    else if (gamePaused) { 
                        gamePaused = false; 
                        hideMessage();
                    }
                }
                if (!isGameRunning || gamePaused) return;
                switch(event.key.toLowerCase()){
                    case 'arrowup': case 'w': keyboardInput.forward = 1; break;
                    case 'arrowdown': case 's': keyboardInput.back = 1; break;
                    case 'arrowleft': case 'a': keyboardInput.left = 1; break;
                    case 'arrowright': case 'd': keyboardInput.right = 1; break;
                    case ' ': keyboardInput.kick = true; break; 
                }
            });
            document.addEventListener('keyup', (event) => {
                if (!isGameRunning) return;
                 switch(event.key.toLowerCase()){
                    case 'arrowup': case 'w': keyboardInput.forward = 0; break;
                    case 'arrowdown': case 's': keyboardInput.back = 0; break;
                    case 'arrowleft': case 'a': keyboardInput.left = 0; break;
                    case 'arrowright': case 'd': keyboardInput.right = 0; break;
                    case ' ': keyboardInput.kick = false; break;
                }
            });

            // Touch controls for Kick Button
            if (kickButton) {
                kickButton.addEventListener('touchstart', (event) => {
                    event.preventDefault(); 
                    if (isGameRunning && !gamePaused) {
                        keyboardInput.kick = true; 
                        kickButton.classList.add('active');
                    }
                }, { passive: false }); 
                kickButton.addEventListener('touchend', (event) => {
                    event.preventDefault();
                     if (isGameRunning) { 
                        keyboardInput.kick = false;
                        kickButton.classList.remove('active');
                    }
                });
            } else {
                console.error("Kick button not found!");
            }
            
            // Touch controls for Joystick
            if (joystickArea && joystickNub) {
                console.log("Attaching joystick event listeners to joystickArea.");
                joystickArea.addEventListener('touchstart', (event) => {
                    console.log("Joystick touchstart triggered on joystickArea.");
                    event.preventDefault();
                    if (isGameRunning && !gamePaused) {
                        isJoystickActive = true;
                        const touch = event.changedTouches[0];
                        console.log(`Touchstart - ClientX: ${touch.clientX}, ClientY: ${touch.clientY}`);
                        const currentBaseRect = joystickArea.getBoundingClientRect(); 
                        updateJoystickNub(touch.clientX, touch.clientY, currentBaseRect);
                    }
                }, { passive: false });

                // It's often better to put move and end on the document to handle dragging outside
                document.addEventListener('touchmove', (event) => {
                    if (!isJoystickActive || !isGameRunning || gamePaused) return;
                    // event.preventDefault(); // Be careful with preventDefault on document for move
                    const touch = event.changedTouches[0]; 
                    // console.log(`Touchmove - ClientX: ${touch.clientX}, ClientY: ${touch.clientY}`); // Spammy
                    const currentBaseRect = joystickArea.getBoundingClientRect();
                    updateJoystickNub(touch.clientX, touch.clientY, currentBaseRect);
                }, { passive: false }); // passive:false if you intend to prevent scroll during joystick use

                document.addEventListener('touchend', (event) => {
                    if (!isJoystickActive) return; // Only act if our joystick was active
                    console.log("Joystick touchend triggered on document.");
                    // event.preventDefault(); // Usually not needed for touchend on document unless specific case
                    isJoystickActive = false;
                    joystickNub.style.transform = `translate(-50%, -50%)`; 
                    joystickInput = { x: 0, y: 0 };
                    console.log("Joystick deactivated. Input:", joystickInput);
                });
            } else {
                console.error("JoystickArea or JoystickNub not found for event listener attachment!");
            }

            if (muteButton) muteButton.addEventListener('click', toggleMute);
            if (teamNameButton) teamNameButton.addEventListener('click', generateTeamNames);
            if (banterButton) banterButton.addEventListener('click', getGameBanter);
            console.log("Controls initialized.");
        }

        function updateJoystickNub(clientX, clientY, baseRect) {
            if (!joystickNub || !baseRect) {
                console.error("updateJoystickNub: joystickNub or baseRect is null/undefined.");
                return;
            }
            // console.log(`updateJoystickNub - clientX: ${clientX}, clientY: ${clientY}, baseLeft: ${baseRect.left}, baseTop: ${baseRect.top}, baseWidth: ${baseRect.width}`);

            const nubRadius = joystickNub.offsetWidth / 2;
            const baseRadius = baseRect.width / 2; 

            const actualBaseCenterX = baseRect.left + baseRadius;
            const actualBaseCenterY = baseRect.top + baseRadius;

            let deltaX = clientX - actualBaseCenterX;
            let deltaY = clientY - actualBaseCenterY;

            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const maxDistance = baseRadius - nubRadius; 

            if (distance > maxDistance) {
                deltaX = (deltaX / distance) * maxDistance;
                deltaY = (deltaY / distance) * maxDistance;
            }
            
            joystickNub.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
            
            joystickInput.x = maxDistance === 0 ? 0 : deltaX / maxDistance; // Avoid division by zero
            joystickInput.y = maxDistance === 0 ? 0 : deltaY / maxDistance; 

            if (Math.abs(joystickInput.x) < 0.20) joystickInput.x = 0; // Increased deadzone slightly
            if (Math.abs(joystickInput.y) < 0.20) joystickInput.y = 0;
            // console.log(`Joystick Input: x=${joystickInput.x.toFixed(2)}, y=${joystickInput.y.toFixed(2)}`);
        }


        function handleKickOrSprint() {
            // ... (handleKickOrSprint logic - unchanged)
            if (!g_player1.mesh || !gameMeshes.ball) return;

            const player = g_player1;
            const playerPos = player.mesh.position;
            const ballPos = gameMeshes.ball.position;
            const distanceToBall = playerPos.distanceTo(ballPos);
            const kickRange = (PLAYER_BODY_RADIUS_BOTTOM_3D + BALL_RADIUS_3D) * KICK_RANGE_MULTIPLIER;

            if (distanceToBall < kickRange && player.hasBall) { 
                // console.log("Kick action!");
                playSoundEffect('kickHard');
                player.hasBall = false;
                ballPhysics.controlledBy = null;

                const playerDirection = new THREE.Vector3();
                player.mesh.getWorldDirection(playerDirection); 
                
                const kickStrength = 20 * METER_TO_3D_UNIT; 
                ballPhysics.velocity.copy(playerDirection).multiplyScalar(kickStrength);
                ballPhysics.velocity.y = 2.5 * METER_TO_3D_UNIT; 

            } else if (!player.isSprinting) { 
                // console.log("Sprint action!");
                player.isSprinting = true;
                player.currentSpeed = PLAYER_SPRINT_SPEED;
                player.sprintTimer = SPRINT_DURATION;
            }
        }


        function resetGeminiUsage() { 
            // ... (resetGeminiUsage logic - unchanged)
            apiCallCount = 0; 
            geminiFeaturesDisabled = false; 
            if(teamNameButton) teamNameButton.disabled = false; 
            if(banterButton) banterButton.disabled = false;
        }

        async function callGemini(prompt, isJson = false) {
            // ... (callGemini logic - unchanged)
            if (geminiFeaturesDisabled) return "Gemini features temporarily disabled.";
            if (apiCallCount >= MAX_API_CALLS_PER_GAME) {
                geminiFeaturesDisabled = true;
                if(teamNameButton) teamNameButton.disabled = true;
                if(banterButton) banterButton.disabled = true;
                showMessage("Max AI features used for this game.", true, 2000);
                return "Max API calls reached. Try again next game.";
            }
            apiCallCount++;
            const apiKey = ""; 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
            let chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
            const payload = { contents: chatHistory };
            if (isJson) { /* ... schema ... */ }
            try {
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) { const errorBody = await response.text(); showMessage(`AI Error: ${response.statusText}`, true, 2000); return `Error: ${response.statusText}`; }
                const result = await response.json();
                if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts) return result.candidates[0].content.parts[0].text;
                showMessage("AI gave an unusual response.", true, 2000); return "Received an unexpected response from the AI.";
            } catch (error) { showMessage("Could not connect to AI.", true, 2000); return "Error connecting to the AI service."; }
        }

        async function generateTeamNames() { /* ... unchanged ... */ 
            if (!teamNameButton || !g_player1 || !g_player2) return;
            teamNameButton.disabled = true; teamNameButton.textContent = "Naming...";
            const prompt = "Generate two distinct, creative, and fun soccer team names. Format them as: Team Name 1, Team Name 2.";
            const responseText = await callGemini(prompt);
            if (responseText && typeof responseText === 'string' && !responseText.startsWith("Error") && !responseText.startsWith("Max API calls")) {
                const names = responseText.split(',').map(name => name.trim());
                if (names.length >= 2) { g_player1.teamName = names[0] || "Team Alpha"; g_player2.teamName = names[1] || "Team Beta";
                    if(banterDisplay) { banterDisplay.textContent = `Today's match: ${g_player1.teamName} vs ${g_player2.teamName}!`; banterDisplay.style.display = 'block'; setTimeout(() => { if(banterDisplay) banterDisplay.style.display = 'none'; }, 3000); }
                } else { g_player1.teamName = "The Comets"; g_player2.teamName = "The Dynamos";
                     if(banterDisplay) { banterDisplay.textContent = "AI couldn't decide on names, using defaults!"; banterDisplay.style.display = 'block'; setTimeout(() => { if(banterDisplay) banterDisplay.style.display = 'none'; }, 3000); }
                }
            } else { if(banterDisplay && typeof responseText === 'string') { banterDisplay.textContent = responseText; banterDisplay.style.display = 'block'; setTimeout(() => { if(banterDisplay) banterDisplay.style.display = 'none'; }, 3000); } }
            updateScores(); teamNameButton.disabled = geminiFeaturesDisabled; teamNameButton.textContent = "✨ Names";
        }
        async function getGameBanter() { /* ... unchanged ... */
            if (!banterButton || !banterDisplay) return;
            banterButton.disabled = true; banterDisplay.textContent = "Thinking of some banter..."; banterDisplay.style.display = 'block';
            let scoreInfo = ""; if (g_player1 && g_player2) { scoreInfo = `The score is ${g_player1.teamName || 'Team 1'} ${g_player1.score} - ${g_player2.teamName || 'Team 2'} ${g_player2.score}.`; }
            const timeInfo = `Time remaining: ${Math.ceil(timeLeft)} seconds.`;
            const prompt = `Generate a short, witty, or insightful piece of soccer commentary or banter. ${scoreInfo} ${timeInfo} Keep it under 150 characters.`;
            const banterText = await callGemini(prompt); 
            if(banterDisplay) banterDisplay.textContent = banterText;
            setTimeout(() => { if (banterDisplay && banterDisplay.textContent === banterText) { } }, 5000);
            if(banterButton) banterButton.disabled = geminiFeaturesDisabled;
         }
        async function initAudio() { /* ... unchanged ... */
            if (audioInitialized || (Tone && Tone.context && Tone.context.state === 'running')) { audioInitialized = true; return; }
            try { await Tone.start();
                soundEffects.kickSoft = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 }, volume: -12 }).toDestination();
                soundEffects.kickHard = new Tone.NoiseSynth({ noise: { type: "white" }, envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.05 }, volume: -10 }).toDestination();
                soundEffects.ballBounce = new Tone.MembraneSynth({ pitchDecay: 0.03, octaves: 2, envelope: { attack: 0.005, decay: 0.15, sustain: 0 }, volume: -15 }).toDestination();
                soundEffects.whistleShort = new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.1 }, volume: -15 }).toDestination();
                soundEffects.whistleLong = new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.01, decay: 0.8, sustain: 0.2, release: 0.2 }, volume: -15 }).toDestination();
                soundEffects.goalCheer = new Tone.NoiseSynth({ noise: {type: "pink"}, envelope: {attack: 0.1, decay:1.5, sustain: 0.5, release:0.5}, volume: -18}).toDestination();
                audioInitialized = true;
            } catch (e) { console.error("Could not start audio context or create effects:", e); audioInitialized = false; if(muteButton) muteButton.textContent = "Audio Err"; isMuted = true; }
        }
        function playSoundEffect(soundName, options = {}) { /* ... unchanged ... */
            if (isMuted || !audioInitialized) return;
            const effect = soundEffects[soundName]; if (!effect || (typeof effect.disposed !== 'undefined' && effect.disposed)) return;
            const now = Date.now(); if (soundDebounceTimes[soundName] && (now - soundDebounceTimes[soundName] < DEBOUNCE_THRESHOLD_MS)) return;
            soundDebounceTimes[soundName] = now;
            try { if (typeof effect.triggerAttackRelease === 'function') {
                    const duration = options.duration || (effect.envelope ? effect.envelope.decay + effect.envelope.release : 0.2);
                    const note = options.note || (effect.oscillator ? effect.oscillator.frequency.value : 'C4'); 
                    let velocity = options.velocity || 0.8;
                    if (soundName === 'ballBounce') velocity = Math.min(0.8, Math.max(0.1, Math.abs(ballPhysics.velocity.y / (METER_TO_3D_UNIT * 3) )));
                    if (effect instanceof Tone.NoiseSynth || effect instanceof Tone.MembraneSynth) effect.triggerAttackRelease(duration, Tone.now(), velocity);
                    else if (effect instanceof Tone.Synth) effect.triggerAttackRelease(note, duration, Tone.now(), velocity);
                }
            } catch (e) {}
        }
        function toggleMute() { /* ... unchanged ... */ isMuted = !isMuted; if (muteButton) muteButton.textContent = isMuted ? "Unmute" : "Mute"; if (!isMuted && !audioInitialized) initAudio(); }
        function updateScores() { /* ... unchanged ... */ if (player1ScoreDisplay) player1ScoreDisplay.textContent = `${g_player1.teamName || 'P1'}: ${g_player1.score}`; if (player2ScoreDisplay) player2ScoreDisplay.textContent = `${g_player2.teamName || 'P2'}: ${g_player2.score}`; }
        function updateTimerDisplay() { /* ... unchanged ... */ if (timerDisplay) timerDisplay.textContent = `Time: ${Math.max(0, Math.ceil(timeLeft))}`; }
        function showMessage(message, isError = false, duration = 0) { /* ... unchanged ... */
            if (!messageDisplay) return; messageDisplay.textContent = message; messageDisplay.classList.remove('goal-celebration', 'error'); if (isError) messageDisplay.classList.add('error'); 
            messageDisplay.classList.add('show'); messageDisplay.style.display = 'block'; 
            if (duration > 0) { setTimeout(() => { hideMessage(); }, duration); }
        }
        function hideMessage() { /* ... unchanged ... */
            if (!messageDisplay) return; messageDisplay.classList.remove('show'); messageDisplay.classList.add('hide');
            const handleTransitionEnd = () => { if (!messageDisplay.classList.contains('show')) messageDisplay.style.display = 'none'; messageDisplay.removeEventListener('transitionend', handleTransitionEnd); };
            messageDisplay.addEventListener('transitionend', handleTransitionEnd);
            setTimeout(() => { if (!messageDisplay.classList.contains('show')) messageDisplay.style.display = 'none'; }, 250); 
        }
        function goalScored(scoringTeam) { /* ... unchanged ... */
            playSoundEffect('goalCheer'); playSoundEffect('whistleLong'); 
            let goalMessage = "GOAL!!!";
            if (scoringTeam === 1) { g_player1.score++; goalMessage = `${g_player1.teamName || 'Player 1'} scores! GOAL!`; } 
            else if (scoringTeam === 2) { g_player2.score++; goalMessage = `${g_player2.teamName || 'Player 2'} scores! GOAL!`; }
            updateScores();
            if (messageDisplay) { messageDisplay.textContent = goalMessage; messageDisplay.classList.add('show', 'goal-celebration'); messageDisplay.style.display = 'block'; }
            gamePaused = true; 
            setTimeout(() => { if (isGameRunning) { resetForKickOff(false); hideMessage(); gamePaused = false; } }, 3000); 
        }
        function resetForKickOff(isNewGame) { /* ... unchanged ... */
            if (isNewGame) { g_player1.score = 0; g_player2.score = 0; updateScores(); }
            const playerY = PLAYER_Y_OFFSET; 
            if (gameMeshes.player1) gameMeshes.player1.position.set(PITCH_WIDTH_3D * 0.1, playerY, PITCH_LENGTH_3D * 0.05);
            if (gameMeshes.player2) gameMeshes.player2.position.set(-PITCH_WIDTH_3D * 0.1, playerY, -PITCH_LENGTH_3D * 0.05);
            if (gameMeshes.gk1) gameMeshes.gk1.position.set(0, playerY, PITCH_LENGTH_3D / 2 - GOAL_DEPTH_3D * 1.5);
            if (gameMeshes.gk2) gameMeshes.gk2.position.set(0, playerY, -PITCH_LENGTH_3D / 2 + GOAL_DEPTH_3D * 1.5);
            if (gameMeshes.ball) { gameMeshes.ball.position.set(0, BALL_RADIUS_3D, 0); ballPhysics.velocity.set(0,0,0); ballPhysics.controlledBy = null; g_player1.hasBall = false; }
            if (gameMeshes.player1) gameMeshes.player1.rotation.y = 0; 
            if (gameMeshes.player2) gameMeshes.player2.rotation.y = Math.PI;  
            if (gameMeshes.gk1) gameMeshes.gk1.rotation.y = Math.PI; 
            if (gameMeshes.gk2) gameMeshes.gk2.rotation.y = 0;
        }
        function updatePlayerPositions(deltaTime) { /* ... unchanged ... */
            if (!g_player1.mesh || !isGameRunning || gamePaused) return; 
            const player = g_player1; const playerMesh = player.mesh;
            if (player.isSprinting) { player.sprintTimer -= deltaTime; if (player.sprintTimer <= 0) { player.isSprinting = false; player.currentSpeed = PLAYER_NORMAL_SPEED; } }
            let inputX = joystickInput.x + (keyboardInput.right - keyboardInput.left); let inputY = joystickInput.y + (keyboardInput.back - keyboardInput.forward); 
            inputX = Math.max(-1, Math.min(1, inputX)); inputY = Math.max(-1, Math.min(1, inputY));
            if (keyboardInput.kick && !player.kickProcessedThisFrame) { handleKickOrSprint(); player.kickProcessedThisFrame = true; }
            if (!keyboardInput.kick) player.kickProcessedThisFrame = false;
            if (inputX !== 0 || inputY !== 0) {
                const cameraDirection = new THREE.Vector3(); camera.getWorldDirection(cameraDirection); const angle = Math.atan2(cameraDirection.x, cameraDirection.z);
                const moveDirection = new THREE.Vector3(inputX, 0, -inputY); moveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle); moveDirection.normalize();
                const velocity = moveDirection.multiplyScalar(player.currentSpeed * deltaTime); playerMesh.position.add(velocity);
                const targetAngle = Math.atan2(moveDirection.x, moveDirection.z); const currentAngle = playerMesh.rotation.y;
                let angleDiff = targetAngle - currentAngle; while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI; while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                playerMesh.rotation.y += angleDiff * 0.2; 
                if (player.hasBall && gameMeshes.ball) {
                    const ballOffset = new THREE.Vector3(0,0, PLAYER_BODY_RADIUS_BOTTOM_3D + BALL_RADIUS_3D + 0.05 * METER_TO_3D_UNIT); 
                    ballOffset.applyQuaternion(playerMesh.quaternion); gameMeshes.ball.position.copy(playerMesh.position).add(ballOffset);
                    gameMeshes.ball.position.y = BALL_RADIUS_3D; ballPhysics.velocity.set(0,0,0); 
                }
            }
            const halfPitchW = PITCH_WIDTH_3D / 2 - PLAYER_BODY_RADIUS_BOTTOM_3D; const halfPitchL = PITCH_LENGTH_3D / 2 - PLAYER_BODY_RADIUS_BOTTOM_3D;
            playerMesh.position.x = Math.max(-halfPitchW, Math.min(halfPitchW, playerMesh.position.x)); playerMesh.position.z = Math.max(-halfPitchL, Math.min(halfPitchL, playerMesh.position.z));
            playerMesh.position.y = PLAYER_Y_OFFSET; 
        }
        function updateBallPhysics(deltaTime) { /* ... unchanged ... */
            if (!gameMeshes.ball || !isGameRunning || gamePaused) return;
            const ball = gameMeshes.ball; const player = g_player1; 
            if (!player.hasBall) { 
                const gravity = 9.81 * METER_TO_3D_UNIT * 0.3; 
                if (ball.position.y > BALL_RADIUS_3D) ballPhysics.velocity.y -= gravity * deltaTime;
                ball.position.addScaledVector(ballPhysics.velocity, deltaTime);
                ballPhysics.velocity.x *= ballPhysics.friction; ballPhysics.velocity.z *= ballPhysics.friction;
                if (ball.position.y <= BALL_RADIUS_3D) ballPhysics.velocity.y *= ballPhysics.friction * 0.9; 
                if (ball.position.y < BALL_RADIUS_3D) {
                    ball.position.y = BALL_RADIUS_3D;
                    if (Math.abs(ballPhysics.velocity.y) > 0.2 * METER_TO_3D_UNIT) { ballPhysics.velocity.y *= -0.5; playSoundEffect('ballBounce'); } 
                    else ballPhysics.velocity.y = 0;
                }
                const halfPitchW_ball = PITCH_WIDTH_3D / 2 - BALL_RADIUS_3D; const halfPitchL_ball = PITCH_LENGTH_3D / 2 - BALL_RADIUS_3D;
                if (Math.abs(ball.position.x) > halfPitchW_ball) { ball.position.x = Math.sign(ball.position.x) * halfPitchW_ball; ballPhysics.velocity.x *= -0.7; playSoundEffect('ballBounce'); }
                if (Math.abs(ball.position.z) > halfPitchL_ball) { if (!checkGoal()) { ball.position.z = Math.sign(ball.position.z) * halfPitchL_ball; ballPhysics.velocity.z *= -0.7; playSoundEffect('ballBounce'); } }
                if (ballPhysics.velocity.lengthSq() < (0.05 * METER_TO_3D_UNIT)**2 ) ballPhysics.velocity.set(0,0,0);
                if (g_player1.mesh) { 
                    const distanceToP1 = ball.position.distanceTo(g_player1.mesh.position);
                    const controlRange = (PLAYER_BODY_RADIUS_BOTTOM_3D + BALL_RADIUS_3D) * 1.2; 
                    if (distanceToP1 < controlRange && ballPhysics.velocity.lengthSq() < (PLAYER_NORMAL_SPEED * 0.5)**2) { g_player1.hasBall = true; ballPhysics.controlledBy = g_player1; }
                }
            }
        }
        function updateCamera(deltaTime) { /* ... unchanged ... */
            if (!camera || !g_player1.mesh) return;
            const playerPos = g_player1.mesh.position;
            let targetCamPos = new THREE.Vector3(); const baseOffset = new THREE.Vector3(0, PITCH_WIDTH_3D * 0.45, -PITCH_LENGTH_3D * 0.30); 
            targetCamPos.copy(playerPos).add(baseOffset);
            let lookAtTarget = new THREE.Vector3().copy(playerPos); lookAtTarget.y += PLAYER_Y_OFFSET * 0.5; 
            camera.position.lerp(targetCamPos, 0.08); camera.lookAt(lookAtTarget);
        }
        function checkGoal() { /* ... unchanged ... */
            if (!gameMeshes.ball || gamePaused) return false;
            const ballPos = gameMeshes.ball.position; const goalLineZ_P1 = PITCH_LENGTH_3D / 2; const goalLineZ_P2 = -PITCH_LENGTH_3D / 2; 
            const halfGoalWidth = GOAL_WIDTH_3D / 2 - BALL_RADIUS_3D; 
            if (ballPos.z > goalLineZ_P1 && ballPos.z < goalLineZ_P1 + GOAL_DEPTH_3D * 0.8 && Math.abs(ballPos.x) < halfGoalWidth && ballPos.y < GOAL_HEIGHT_3D - BALL_RADIUS_3D) { goalScored(1); return true; }
            if (ballPos.z < goalLineZ_P2 && ballPos.z > goalLineZ_P2 - GOAL_DEPTH_3D * 0.8 && Math.abs(ballPos.x) < halfGoalWidth && ballPos.y < GOAL_HEIGHT_3D - BALL_RADIUS_3D) { goalScored(2); return true; }
            return false;
        }
        function updateTimer(deltaTime) { /* ... unchanged ... */ if (!isGameRunning || gamePaused) return; timeLeft -= deltaTime; updateTimerDisplay(); if (timeLeft <= 0) endGame(); }
        function endGame() { /* ... unchanged ... */
            isGameRunning = false; gamePaused = true; playSoundEffect('whistleLong');
            let endMessage = "Full Time! ";
            if (g_player1.score > g_player2.score) endMessage += `${g_player1.teamName} wins!`;
            else if (g_player2.score > g_player1.score) endMessage += `${g_player2.teamName} wins!`;
            else endMessage += "It's a draw!";
            showMessage(endMessage, false); console.log("Game Over:", endMessage);
        }

        let lastTime = 0;
        let frameCount = 0; // For animate loop logging
        function animate(currentTime) {
            if (!isGameRunning && !gamePaused && timeLeft <=0) return;
            if (!renderer || !scene || !camera) { console.error("Render components not ready, stopping animation."); return; }

            // console.log(`Animating frame: ${frameCount++}`); // Check if animate is called

            gameLoopId = requestAnimationFrame(animate);
            
            const now = performance.now();
            const deltaTime = Math.min(0.05, (now - (lastTime || now)) / 1000); 
            lastTime = now;

            if (isGameRunning && !gamePaused) {
                updatePlayerPositions(deltaTime);
                updateBallPhysics(deltaTime); 
                updateTimer(deltaTime); 
            }
            
            updateCamera(deltaTime); 

            try {
                renderer.render(scene, camera);
            } catch (e) {
                console.error("Error during render:", e);
                cancelAnimationFrame(gameLoopId); // Stop animation loop on critical render error
            }
        }

        console.log("Script execution finished initial setup.");
    </script>
</body>
</html>

