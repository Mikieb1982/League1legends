<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pixel Pitch Pro - Kick Logic Debugging</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        :root {
            --primary-accent: #00AEEF; 
            --secondary-accent: #FFD700; 
            
            --player1-jersey: #D00000; 
            --player1-shorts: #202020; 
            --player1-trim: #FFFFFF;
            --gk1-jersey: #FF8C00; 

            --player2-jersey: #0057B7; 
            --player2-shorts: #FFFFFF; 
            --player2-trim: #FFD700; 
            --gk2-jersey: #32CD32;   
            
            --ball-color: #FFFFFF;
            --ball-panel-color: #1E1E1E;
            --background-dark: #121212; 
            --pitch-grass-light: #4A7A3A; 
            --pitch-grass-dark: #3E6630;  
            --pitch-line-color: rgba(255, 255, 255, 0.75);
            --goal-post-color: #E0E0E0; 
            --goal-net-color: rgba(220, 220, 220, 0.3);
            
            --ui-panel-bg: rgba(28, 28, 32, 0.9); 
            --text-light: #F5F5F5;
            --text-dark: #121212; 
            --text-secondary: #A0A0A0; 

            --joystick-base-bg: rgba(50, 50, 55, 0.7);  
            --joystick-nub-bg: var(--primary-accent);
            --joystick-nub-border: rgba(255, 255, 255, 0.9);
            
            --action-button-bg: var(--primary-accent);
            --action-button-text: #FFFFFF;
            --action-button-active-bg: #008ECC; 
            
            --gemini-button-bg: var(--secondary-accent);
            --gemini-button-text: #121212;
            --gemini-button-border: #DAA520; 
            --shadow-color: rgba(0, 0, 0, 0.35);
        }

        html, body {
            height: 100%;
            overflow: hidden;
            background-color: var(--background-dark);
            font-family: 'Inter', sans-serif;
            color: var(--text-light);
        }

        body {
            margin: 0;
            padding: 0;
            display: flex; 
            justify-content: center;
            align-items: center;
        }

        #gameWrapper {
            width: 100%;
            height: 100%;
            position: relative; 
            background-color: #222; 
        }
        
        #gameContainer {
            width: 100%;
            height: 100%;
            position: absolute; 
            top: 0;
            left: 0;
            overflow: hidden; 
            z-index: 1; 
        }

        #uiContainer {
            position: absolute; 
            top: 10px; left: 50%; transform: translateX(-50%);
            padding: 8px 15px; background-color: var(--ui-panel-bg); border-radius: 12px; 
            z-index: 100; display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;
            align-items: center; box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        .ui-button { font-family: 'Inter', sans-serif; font-weight: 600; background-color: var(--primary-accent); border: none; color: var(--text-light); padding: 8px 15px; font-size: clamp(12px, 2vw, 14px); cursor: pointer; border-radius: 8px; text-shadow: none; transition: background-color 0.2s, transform 0.1s; }
        .ui-button:hover:not(:disabled) { background-color: var(--action-button-active-bg); transform: translateY(-1px); }
        .ui-button:disabled { background-color: #444; color: #888; cursor: not-allowed; }
        .gemini-button { background-color: var(--gemini-button-bg); color: var(--gemini-button-text); }
        .gemini-button:hover:not(:disabled) { background-color: var(--gemini-button-border); }
        .gemini-button:disabled { background-color: #756633; }

        .score, #timerDisplay { font-size: clamp(16px, 3vw, 20px); font-weight: 700; color: var(--text-light); text-shadow: 1px 1px 3px rgba(0,0,0,0.5); padding: 5px 10px; background-color: rgba(0,0,0,0.2); border-radius: 6px; }
        #player1Score { color: var(--player1-jersey); border: 1px solid var(--player1-jersey); }
        #player2Score { color: var(--player2-jersey); border: 1px solid var(--player2-jersey); }
        #timerDisplay { color: var(--primary-accent); border: 1px solid var(--primary-accent); }

        #banterDisplay { position: absolute; top: calc(10px + 70px); left: 50%; transform: translateX(-50%); width: auto; max-width: 80%; padding: 8px 15px; box-sizing: border-box; background-color: rgba(30, 30, 35, 0.85); border-radius: 8px; border: 1px solid var(--primary-accent); color: var(--text-light); font-size: clamp(12px, 2.5vw, 15px); font-weight: 400; text-align: center; margin-top: 8px; min-height: 25px; display: none; text-shadow: 1px 1px 2px rgba(0,0,0,0.3); z-index: 99; }
        #messageDisplay { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(1); font-size: clamp(20px, 5vw, 32px); font-weight: 700; color: var(--text-light); text-shadow: 0 0 10px var(--secondary-accent), 2px 2px 5px #000; padding: 18px 25px; background: linear-gradient(145deg, rgba(40,40,45,0.95), rgba(20,20,25,0.95)); border: 2px solid var(--secondary-accent); border-radius: 15px; text-align: center; z-index: 110; display: none; opacity: 0; max-width: 85%; box-shadow: 0 5px 25px rgba(0,0,0,0.5); transition: transform 0.15s ease-out, opacity 0.15s ease-out; }
        #messageDisplay.show { display: block; opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
        #messageDisplay.hide { opacity: 0; transform: translate(-50%, -50%) scale(0.95); }
        #messageDisplay.goal-celebration { animation: goalPulseModern 0.6s ease-out forwards; }
        @keyframes goalPulseModern { 0% { transform: translate(-50%, -50%) scale(1); opacity: 1;} 50% { transform: translate(-50%, -50%) scale(1.15); opacity: 0.85;} 100% { transform: translate(-50%, -50%) scale(1); opacity: 1;} }
        
        #controlsInfo { position: absolute; bottom: 15px; left: 50%; transform: translateX(-50%); font-size: clamp(11px, 1.8vw, 13px); color: var(--text-secondary); text-align: center; z-index: 100; }
        #controlsInfo p { margin: 4px 0; }

        #touchControlsContainer { position: fixed; bottom: clamp(25px, 8vh, 60px); left: 0; width: 100%; padding: 0 clamp(15px, 4vw, 25px); box-sizing: border-box; display: none; justify-content: space-between; align-items: flex-end; z-index: 105; pointer-events: none; }
        .touch-control-area { display: flex; align-items: center; justify-content: center; pointer-events: auto; }
        #joystickArea { width: clamp(120px, 24vmin, 170px); height: clamp(120px, 24vmin, 170px); position: relative; opacity: 0.9; }
        #joystickBase { width: 100%; height: 100%; background-color: var(--joystick-base-bg); border-radius: 50%; border: 2px solid rgba(255,255,255,0.2); box-shadow: 0 0 12px rgba(0,0,0,0.3) inset; }
        #joystickNub { width: clamp(50px, 10vmin, 70px); height: clamp(50px, 10vmin, 70px); background-color: var(--joystick-nub-bg); border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); border: 2px solid var(--joystick-nub-border); box-shadow: 0 0 15px var(--joystick-nub-bg); }
        #actionButtonsArea { display: flex; flex-direction: column; align-items: center; }
        .action-button { width: clamp(75px, 17vmin, 95px); height: clamp(75px, 17vmin, 95px); background-color: var(--action-button-bg) ; border: none; box-shadow: 0 3px 8px rgba(0,0,0,0.4); border-radius: 50%; display: flex; align-items: center; justify-content: center; color: var(--action-button-text); font-family: 'Inter', sans-serif; font-weight: 600; font-size: clamp(11px, 2.5vmin, 14px); text-align: center; opacity: 0.95; margin: 8px; user-select: none; pointer-events: auto; transition: background-color 0.1s ease-out, transform 0.05s ease-out, box-shadow 0.1s ease-out; }
        .action-button:active { background-color: var(--action-button-active-bg); transform: scale(0.92); box-shadow: 0 1px 4px rgba(0,0,0,0.3); }

    </style>
</head>
<body>
    <div id="gameWrapper">
        <div id="uiContainer">
            <div id="player1Score" class="score">P1: 0</div>
            <div id="timerDisplay" class="score">Time: 90</div>
            <button id="muteButton" class="ui-button">Mute</button>
            <button id="teamNameButton" class="ui-button gemini-button">✨ Names</button>
            <button id="banterButton" class="ui-button gemini-button">✨ Banter</button>
            <div id="player2Score" class="score">P2: 0</div>
        </div>
        <div id="banterDisplay"></div> 
        
        <div id="gameContainer"></div>

        <div id="messageDisplay">Message</div>
        <div id="controlsInfo">
             <p>P1: Arrows/WASD, Space/K to Kick/Sprint</p>
             <p>Enter to Start/Restart</p>
        </div>
    </div>

    <div id="touchControlsContainer"> 
        <div id="joystickArea" class="touch-control-area">
            <div id="joystickBase"></div>
            <div id="joystickNub"></div>
        </div>
        <div id="actionButtonsArea" class="touch-control-area">
            <button id="kickButton" class="action-button">KICK</button>
        </div>
    </div>

    <script>
        console.log("Script execution started.");

        // --- Three.js Scene Variables ---
        let scene, camera, renderer, debugCube;
        let pitchMesh;
        const PITCH_WIDTH_3D = 34; 
        const PITCH_LENGTH_3D = 52.5; 
        const PLAYER_CYLINDER_RADIUS = 0.35; 
        const PLAYER_CYLINDER_HEIGHT = 1.0;  
        const PLAYER_HEAD_RADIUS = 0.25;
        const BALL_RADIUS_3D = 0.2;  
        const GOAL_WIDTH_3D = 7.32 / 2; 
        const GOAL_HEIGHT_3D = 2.44 / 1.5; 
        const GOAL_DEPTH_3D = 1.0; 
        const GOAL_POST_RADIUS = 0.06;
        const gameMeshes = { player1: null, player2: null, gk1: null, gk2: null, ball: null, goal1: null, goal2: null };


        // --- Gemini API & Sound Engine (Stubs for now) ---
        const banterDisplay = document.getElementById('banterDisplay');
        const teamNameButton = document.getElementById('teamNameButton');
        const banterButton = document.getElementById('banterButton');
        let apiCallCount = 0; 
        const MAX_API_CALLS_PER_GAME = 10; 
        let geminiFeaturesDisabled = false; 
        function resetGeminiUsage() { /* console.log("Gemini usage reset."); */ apiCallCount = 0; geminiFeaturesDisabled = false; if(teamNameButton) teamNameButton.disabled = false; if(banterButton) banterButton.disabled = false;}
        async function callGemini(prompt) { /* console.log("Gemini called (stub)"); */ apiCallCount++; return "Banter text"; } 
        async function generateTeamNames() { /* console.log("Generating team names (stub)"); */ await callGemini("names");}
        async function getGameBanter() { /* console.log("Getting banter (stub)"); */ await callGemini("banter");}
        let isMuted = false;
        async function initAudio() { /* console.log("Audio init (stub)"); */ }
        function playSoundEffect(soundName, options = {}) { /* console.log(`Play sound: ${soundName} (stub)`); */ } 
        // --- End Stubs ---

        // --- Game Setup ---
        const gameContainerElement = document.getElementById('gameContainer');
        const player1ScoreDisplay = document.getElementById('player1Score');
        const player2ScoreDisplay = document.getElementById('player2Score');
        const timerDisplay = document.getElementById('timerDisplay');
        const messageDisplay = document.getElementById('messageDisplay');
        const controlsInfoDisplay = document.getElementById('controlsInfo');
        const touchControlsContainer = document.getElementById('touchControlsContainer');
        const joystickArea = document.getElementById('joystickArea');
        const joystickNub = document.getElementById('joystickNub');
        const kickButton = document.getElementById('kickButton');
        
        const LOGICAL_PITCH_WIDTH = 1000; 
        const LOGICAL_PITCH_HEIGHT = 680; 
        
        const GAME_DURATION_SECONDS = 90; 
        const AI_SPEED_MODIFIER = 0.9; 
        const AI_SPRINT_MODIFIER = 1.3; 
        const KICK_CHARGE_RATE = 0.06; 
        const MAX_KICK_CHARGE = 1.0; 
        const MIN_KICK_POWER_FACTOR = 0.25; 
        const AI_KICK_POWER_FACTOR = 0.7;
        const KICK_TAP_THRESHOLD_MS = 180; 


        let PLAYER_RADIUS_LOGICAL, GOALKEEPER_RADIUS_LOGICAL, BALL_RADIUS_LOGICAL;
        let PLAYER_SPEED, GOALKEEPER_SPEED, PLAYER_SPRINT_MULTIPLIER, KICK_STRENGTH, MAX_BALL_SPEED, PASS_STRENGTH;
        let PLAYER_INERTIA, BALL_INERTIA;
        let DRIBBLING_DISTANCE_THRESHOLD, DRIBBLING_OFFSET_DISTANCE;

        let player1, player2, ball, goalkeeper1, goalkeeper2;
        let keys = {};
        
        let timeLeft = GAME_DURATION_SECONDS; 
        let gameTimerInterval; 
        let gameState = 'INITIAL'; 
        let isTouchDevice = false; 
        let lastTime = 0; 
        let frameCount = 0; 


        function distance(x1, y1, x2, y2) { return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2); }
        function showMessage(text, duration = 2000, isGoal = false) { 
            messageDisplay.textContent = text;
            messageDisplay.classList.remove('hide', 'goal-celebration');
            messageDisplay.classList.add('show');
            messageDisplay.style.display = 'block'; 
            if (isGoal) messageDisplay.classList.add('goal-celebration');
            if (duration > 0) {
                setTimeout(() => {
                    messageDisplay.classList.remove('show'); messageDisplay.classList.add('hide');
                    setTimeout(() => { if (messageDisplay.classList.contains('hide')) { messageDisplay.style.display = 'none'; messageDisplay.classList.remove('hide'); } }, 150);
                    if (gameState === 'GOAL_SCORED') { resetPositions(false); gameState = 'READY'; setTimeout(() => { if (gameState === 'READY') gameState = 'PLAYING';}, 1000); }
                }, duration);
            } else { messageDisplay.style.display = 'block'; }
        }
        function updateScores() { 
            if(player1 && player2) { 
                let p1Name = (player1.teamName && player1.teamName !== "P1") ? player1.teamName : "Team 1"; 
                let p2Name = (player2.teamName && player2.teamName !== "P2") ? player2.teamName : "Team 2"; 
                player1ScoreDisplay.textContent = `${p1Name}: ${player1.score}`; 
                player2ScoreDisplay.textContent = `${p2Name}: ${player2.score}`; 
            } 
        }
        function updateTimerDisplay() { timerDisplay.textContent = `Time: ${timeLeft}`; }

        // --- Three.js Initialization & Drawing ---
        function initThreeJSScene() {
            console.log("Attempting to initialize Three.js scene...");
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x102030); 
            scene.fog = new THREE.Fog(scene.background, PITCH_LENGTH_3D * 0.8, PITCH_LENGTH_3D * 2.5);

            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(50, aspect, 0.1, 200);
            camera.position.set(0, PITCH_LENGTH_3D * 0.65, PITCH_WIDTH_3D * 0.9 + 20); 
            camera.lookAt(0, -PLAYER_CYLINDER_HEIGHT * 0.2 , 0); 
            console.log("Camera created.");

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            if (!gameContainerElement) { console.error("CRITICAL: gameContainerElement not found!"); return; }
            gameContainerElement.appendChild(renderer.domElement);
            console.log("Renderer appended.");

            const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
            scene.add(hemisphereLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
            dirLight.position.set(-30, 40, 25); 
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048; dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.near = 5; dirLight.shadow.camera.far = 120; 
            dirLight.shadow.camera.left = -PITCH_WIDTH_3D * 1.2; dirLight.shadow.camera.right = PITCH_WIDTH_3D * 1.2;
            dirLight.shadow.camera.top = PITCH_LENGTH_3D * 1.2; dirLight.shadow.camera.bottom = -PITCH_LENGTH_3D * 1.2;
            scene.add(dirLight);
            console.log("Lights added.");

            createPitch3D();
            createGoals3D();
            createPlayerMeshes();
            createBallMesh();
            
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
            debugCube = new THREE.Mesh(geometry, material);
            debugCube.position.set(0, 5, 0); 
            scene.add(debugCube);
            console.log("Debug cube added.");

            window.addEventListener('resize', onWindowResizeThree, false);
            console.log("Three.js scene initialization complete. Starting gameLoop.");
            if (renderer && scene && camera) gameLoop(); else console.error("Render loop start aborted.");
        }

        function createPitch3D() {
            const pitchCanvas = document.createElement('canvas');
            const pitchCtx = pitchCanvas.getContext('2d');
            pitchCanvas.width = 256; pitchCanvas.height = 512; 
            const numStripes = 14; 
            const stripeHeight = pitchCanvas.height / numStripes;
            for(let i=0; i<numStripes; i++){
                pitchCtx.fillStyle = (i%2 === 0) ? getComputedStyle(document.documentElement).getPropertyValue('--pitch-grass-light').trim() 
                                                : getComputedStyle(document.documentElement).getPropertyValue('--pitch-grass-dark').trim();
                pitchCtx.fillRect(0, i*stripeHeight, pitchCanvas.width, stripeHeight);
            }
            const pitchTexture = new THREE.CanvasTexture(pitchCanvas);
            pitchTexture.wrapS = THREE.RepeatWrapping; pitchTexture.wrapT = THREE.RepeatWrapping;
            pitchTexture.repeat.set(PITCH_WIDTH_3D / 8, PITCH_LENGTH_3D / 8); 
            pitchTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();

            const pitchMaterial = new THREE.MeshStandardMaterial({ map: pitchTexture, roughness: 0.9, metalness: 0.05 }); 
            pitchMesh = new THREE.Mesh(new THREE.PlaneGeometry(PITCH_WIDTH_3D, PITCH_LENGTH_3D), pitchMaterial);
            pitchMesh.rotation.x = -Math.PI / 2; 
            pitchMesh.receiveShadow = true;
            scene.add(pitchMesh);
            drawPitchLines3D();
            console.log("Pitch created.");
        }

        function drawPitchLines3D() {
            const material = new THREE.LineBasicMaterial({ color: new THREE.Color(getComputedStyle(document.documentElement).getPropertyValue('--pitch-line-color').trim())}); 
            const points = [];
            const y = 0.02; 

            points.push(new THREE.Vector3(-PITCH_WIDTH_3D / 2, y, -PITCH_LENGTH_3D / 2));
            points.push(new THREE.Vector3(PITCH_WIDTH_3D / 2, y, -PITCH_LENGTH_3D / 2));
            points.push(new THREE.Vector3(PITCH_WIDTH_3D / 2, y, PITCH_LENGTH_3D / 2));
            points.push(new THREE.Vector3(-PITCH_WIDTH_3D / 2, y, PITCH_LENGTH_3D / 2));
            points.push(new THREE.Vector3(-PITCH_WIDTH_3D / 2, y, -PITCH_LENGTH_3D / 2));
            points.push(new THREE.Vector3(-PITCH_WIDTH_3D / 2, y, 0)); 
            points.push(new THREE.Vector3(PITCH_WIDTH_3D / 2, y, 0)); 
            
            let geometry = new THREE.BufferGeometry().setFromPoints(points);
            scene.add(new THREE.LineSegments(geometry, material));

            const circleRadius = PITCH_LENGTH_3D * 0.15; 
            const circleShape = new THREE.Path();
            circleShape.absarc(0, 0, circleRadius, 0, Math.PI * 2, false);
            const circlePoints = circleShape.getPoints(64); 
            geometry = new THREE.BufferGeometry().setFromPoints(circlePoints);
            const circleLine = new THREE.Line(geometry, material);
            circleLine.rotation.x = -Math.PI / 2;
            circleLine.position.y = y; 
            scene.add(circleLine);
            console.log("Pitch lines drawn.");
        }
        
        function createGoals3D() {
            const postMaterial = new THREE.MeshStandardMaterial({ color: new THREE.Color(getComputedStyle(document.documentElement).getPropertyValue('--goal-post-color').trim()), roughness: 0.3, metalness: 0.5 });
            
            function createGoal(zPos) {
                const goalGroup = new THREE.Group();
                const postGeo = new THREE.CylinderGeometry(GOAL_POST_RADIUS, GOAL_POST_RADIUS, GOAL_HEIGHT_3D, 12);
                const leftPost = new THREE.Mesh(postGeo, postMaterial);
                leftPost.position.set(-GOAL_WIDTH_3D / 2, GOAL_HEIGHT_3D / 2, 0);
                leftPost.castShadow = true; goalGroup.add(leftPost);
                const rightPost = new THREE.Mesh(postGeo, postMaterial);
                rightPost.position.set(GOAL_WIDTH_3D / 2, GOAL_HEIGHT_3D / 2, 0);
                rightPost.castShadow = true; goalGroup.add(rightPost);
                const crossbarGeo = new THREE.CylinderGeometry(GOAL_POST_RADIUS, GOAL_POST_RADIUS, GOAL_WIDTH_3D, 12);
                const crossbar = new THREE.Mesh(crossbarGeo, postMaterial);
                crossbar.rotation.z = Math.PI / 2;
                crossbar.position.set(0, GOAL_HEIGHT_3D, 0);
                crossbar.castShadow = true; goalGroup.add(crossbar);
                goalGroup.position.z = zPos;
                scene.add(goalGroup);
                return goalGroup;
            }
            gameMeshes.goal1 = createGoal(-PITCH_LENGTH_3D / 2 - GOAL_DEPTH_3D / 2); 
            gameMeshes.goal2 = createGoal(PITCH_LENGTH_3D / 2 + GOAL_DEPTH_3D / 2);  
            console.log("Goals created.");
        }

        function createPlayerMesh(colorHex, trimColorHex, isGK = false) {
            const group = new THREE.Group();
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: new THREE.Color(colorHex), roughness: 0.7, metalness: 0.1 });
            const trimMaterial = new THREE.MeshStandardMaterial({ color: new THREE.Color(trimColorHex), roughness: 0.7, metalness: 0.1 });

            const bodyCylinder = new THREE.Mesh(
                new THREE.CylinderGeometry(PLAYER_CYLINDER_RADIUS, PLAYER_CYLINDER_RADIUS, PLAYER_CYLINDER_HEIGHT, 16), 
                bodyMaterial
            );
            bodyCylinder.position.y = PLAYER_CYLINDER_HEIGHT / 2; 
            bodyCylinder.castShadow = true; 
            bodyCylinder.receiveShadow = true;
            group.add(bodyCylinder);

            const headSphere = new THREE.Mesh(
                new THREE.SphereGeometry(PLAYER_HEAD_RADIUS, 16, 12), 
                trimMaterial
            ); 
            headSphere.position.y = PLAYER_CYLINDER_HEIGHT + PLAYER_HEAD_RADIUS * 0.7; 
            headSphere.castShadow = true;
            group.add(headSphere);
            
            if(isGK){ 
                group.scale.set(1.1, 1.1, 1.1); 
            }
            return group;
        }

        function createPlayerMeshes() {
            gameMeshes.player1 = createPlayerMesh(getComputedStyle(document.documentElement).getPropertyValue('--player1-jersey').trim(), getComputedStyle(document.documentElement).getPropertyValue('--player1-trim').trim());
            scene.add(gameMeshes.player1);
            gameMeshes.player2 = createPlayerMesh(getComputedStyle(document.documentElement).getPropertyValue('--player2-jersey').trim(), getComputedStyle(document.documentElement).getPropertyValue('--player2-trim').trim());
            scene.add(gameMeshes.player2);
            gameMeshes.gk1 = createPlayerMesh(getComputedStyle(document.documentElement).getPropertyValue('--gk1-jersey').trim(), getComputedStyle(document.documentElement).getPropertyValue('--player1-trim').trim(), true);
            scene.add(gameMeshes.gk1);
            gameMeshes.gk2 = createPlayerMesh(getComputedStyle(document.documentElement).getPropertyValue('--gk2-jersey').trim(), getComputedStyle(document.documentElement).getPropertyValue('--player2-trim').trim(), true);
            scene.add(gameMeshes.gk2);
            console.log("Player meshes created.");
        }
        
        function createBallMesh() {
            const ballMaterial = new THREE.MeshStandardMaterial({ color: new THREE.Color(getComputedStyle(document.documentElement).getPropertyValue('--ball-color').trim()), roughness: 0.4, metalness: 0.05 });
            gameMeshes.ball = new THREE.Mesh(new THREE.SphereGeometry(BALL_RADIUS_3D, 20, 20), ballMaterial);
            gameMeshes.ball.castShadow = true;
            gameMeshes.ball.receiveShadow = true; 
            scene.add(gameMeshes.ball);
            console.log("Ball mesh created.");
        }
        
        function onWindowResizeThree() {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }
        
        function mapTo3D(logicalX, logicalY) {
            const x3D = (logicalX / LOGICAL_PITCH_WIDTH) * PITCH_WIDTH_3D;
            const z3D = -(logicalY / LOGICAL_PITCH_HEIGHT) * PITCH_LENGTH_3D; 
            return { x: x3D, z: z3D };
        }
        
        function resetPositions(resetScores = true) {
            console.log("Resetting positions. Reset scores:", resetScores);
            
            PLAYER_RADIUS_LOGICAL = 30; 
            GOALKEEPER_RADIUS_LOGICAL = 35; 
            BALL_RADIUS_LOGICAL = 20; 
            PLAYER_SPEED = 12; 
            GOALKEEPER_SPEED = 10; 
            PLAYER_SPRINT_MULTIPLIER = 1.5; 
            KICK_STRENGTH = 300; 
            MAX_BALL_SPEED = 400; 
            PASS_STRENGTH = KICK_STRENGTH * MIN_KICK_POWER_FACTOR * 1.2; 
            PLAYER_INERTIA = 0.96; 
            BALL_INERTIA = 0.98; 
            DRIBBLING_DISTANCE_THRESHOLD = (PLAYER_RADIUS_LOGICAL + BALL_RADIUS_LOGICAL + 8); 
            DRIBBLING_OFFSET_DISTANCE = PLAYER_RADIUS_LOGICAL + BALL_RADIUS_LOGICAL * 0.4; 

            const p1Col = getComputedStyle(document.documentElement).getPropertyValue('--player1-jersey').trim();
            const p2Col = getComputedStyle(document.documentElement).getPropertyValue('--player2-jersey').trim();
            const gk1Col = getComputedStyle(document.documentElement).getPropertyValue('--gk1-jersey').trim();
            const gk2Col = getComputedStyle(document.documentElement).getPropertyValue('--gk2-jersey').trim();
            const ballCol = getComputedStyle(document.documentElement).getPropertyValue('--ball-color').trim();

            let p1ScoreValue = player1 ? player1.score : 0; 
            let p2ScoreValue = player2 ? player2.score : 0;
            let p1Name = player1 ? player1.teamName : "Team 1"; 
            let p2Name = player2 ? player2.teamName : "Team 2";
            if (resetScores) { p1ScoreValue = 0; p2ScoreValue = 0; p1Name = "Team 1"; p2Name = "Team 2"; }

            const playerCommon = { dx: 0, dy: 0, isSprinting: false, hasBall: false, isKicking: false, kickCharge: 0, actionButtonDown: false, actionButtonStartTime: 0, lastMoveAngle: 0 };
            
            player1 = { ...playerCommon, id: 'player1', x: 0, y: LOGICAL_PITCH_HEIGHT / 4, score: p1ScoreValue, color: p1Col, teamName: p1Name, lastMoveAngle: -Math.PI/2 }; 
            player2 = { ...playerCommon, id: 'player2', x: 0, y: -LOGICAL_PITCH_HEIGHT / 4, score: p2ScoreValue, color: p2Col, teamName: p2Name, lastMoveAngle: Math.PI/2 };  
            
            goalkeeper1 = { id: 'gk1', x: 0, y: LOGICAL_PITCH_HEIGHT/2 - GOALKEEPER_RADIUS_LOGICAL * 1.2 , dx:0, dy:0, color: gk1Col}; 
            goalkeeper2 = { id: 'gk2', x: 0, y: -LOGICAL_PITCH_HEIGHT/2 + GOALKEEPER_RADIUS_LOGICAL * 1.2 , dx:0, dy:0, color: gk2Col}; 
            
            ball = { x: 0, y: 0, dx: 0, dy: 0, color: ballCol, controlledBy: null, lastTouchedBy: null };
            
            ['player1', 'player2', 'gk1', 'gk2', 'ball'].forEach(key => {
                let entity;
                if (key === 'player1') entity = player1;
                else if (key === 'player2') entity = player2;
                else if (key === 'gk1') entity = goalkeeper1;
                else if (key === 'gk2') entity = goalkeeper2;
                else if (key === 'ball') entity = ball;

                const mesh = gameMeshes[key];
                if (entity && mesh) {
                    const pos3D = mapTo3D(entity.x, entity.y);
                    let yPos3D = (key === 'ball') ? BALL_RADIUS_3D : 0; 
                    mesh.position.set(pos3D.x, yPos3D, pos3D.z);
                    mesh.rotation.set(0,0,0); 
                    if(key.includes('player') || key.includes('gk')) { 
                        mesh.lookAt(0, mesh.position.y + PLAYER_CYLINDER_HEIGHT / 2 , 0); 
                    }
                } else {
                    console.warn(`Entity or Mesh not found for key: ${key} during resetPositions`);
                }
            });
            updateScores(); 
            console.log("Positions reset.");
        }
        
        // --- Game Logic Update Functions ---
        function updateFieldPlayer(player, isAI = false, deltaTime) {
            if (!player || !ball || !gameMeshes[player.id]) return;
            const dtFactor = deltaTime / (1000/60); 
            
            if (!isAI && player === player1 && frameCount % 180 === 0) { 
                console.log(`[P1 LOGIC DEBUG] Before: x=${player.x.toFixed(1)}, y=${player.y.toFixed(1)}, dx=${player.dx.toFixed(1)}, dy=${player.dy.toFixed(1)}`);
            }

            let currentBaseSpeed = PLAYER_SPEED * (isAI ? AI_SPEED_MODIFIER : 1);
            let actualSpeed = player.isSprinting ? currentBaseSpeed * PLAYER_SPRINT_MULTIPLIER : currentBaseSpeed;
            if (!isAI && player === player1 && frameCount % 180 === 0) console.log(`[P1 LOGIC DEBUG] actualSpeed: ${actualSpeed.toFixed(2)}`);


            let targetDx_logical = 0, targetDy_logical = 0;

            if (!isAI) { // Human Player
                if (player.actionButtonDown) { if (player.hasBall && ball.controlledBy === player) { player.isSprinting = false; if (performance.now() - player.actionButtonStartTime > KICK_TAP_THRESHOLD_MS) player.kickCharge = Math.min(MAX_KICK_CHARGE, player.kickCharge + KICK_CHARGE_RATE); } else player.isSprinting = true; } else player.isSprinting = false; 
                let moveX = 0, moveY = 0; 
                if (isTouchDevice && touchState.joystickActive) { 
                    const relativeX = touchState.joystickCurrentX; 
                    const relativeY = touchState.joystickCurrentY; 
                    const magnitude = Math.sqrt(relativeX * relativeX + relativeY * relativeY); 
                    if (magnitude > JOYSTICK_DEADZONE) { 
                        const effectiveMagnitude = Math.min(1, magnitude); 
                        moveX = (relativeX / magnitude) * effectiveMagnitude; 
                        moveY = -(relativeY / magnitude) * effectiveMagnitude; 
                    } 
                     if (frameCount % 180 === 0 && (moveX !== 0 || moveY !== 0)) console.log(`[P1 LOGIC DEBUG] Joystick input: moveX=${moveX.toFixed(2)}, moveY=${moveY.toFixed(2)}`);
                } else if (!isTouchDevice) { 
                    if (keys['arrowup'] || keys['w']) moveY = 1;  
                    if (keys['arrowdown'] || keys['s']) moveY = -1; 
                    if (keys['arrowleft'] || keys['a']) moveX = -1; 
                    if (keys['arrowright'] || keys['d']) moveX = 1; 
                    if (frameCount % 180 === 0 && (moveX !== 0 || moveY !== 0)) console.log(`[P1 LOGIC DEBUG] Keyboard input: moveX=${moveX}, moveY=${moveY}`);
                }
                if (moveX !== 0 || moveY !== 0) { const normFactor = Math.sqrt(moveX * moveX + moveY * moveY); targetDx_logical = (moveX / normFactor) * actualSpeed; targetDy_logical = (moveY / normFactor) * actualSpeed; }
                 if (!isAI && player === player1 && frameCount % 180 === 0 && (targetDx_logical !==0 || targetDy_logical !==0) ) console.log(`[P1 LOGIC DEBUG] targetDx_logical: ${targetDx_logical.toFixed(2)}, targetDy_logical: ${targetDy_logical.toFixed(2)}`);

            } else { // AI Player Logic (Player 2)
                const P1_DEFENDING_GOAL_Y = LOGICAL_PITCH_HEIGHT / 2;  // Player 1 defends this goal (AI Player 2 attacks this)
                const P2_DEFENDING_GOAL_Y = -LOGICAL_PITCH_HEIGHT / 2; // Player 2 (AI) defends this goal
                const AI_SHOOTING_RANGE_Y_MIN = LOGICAL_PITCH_HEIGHT * 0.20; 

                if (player1.hasBall && player1.y > 0) { 
                    targetDestX_logical = player1.x;
                    targetDestY_logical = player1.y + (P2_DEFENDING_GOAL_Y - player1.y) * 0.3; 
                    player.isSprinting = Math.random() < 0.75; 
                    if (distance(player.x, player.y, player1.x, player1.y) < PLAYER_RADIUS_LOGICAL * 4) {
                        targetDestX_logical = player1.x;
                        targetDestY_logical = player1.y;
                    }
                } else if (player.hasBall && ball.controlledBy === player) { 
                    targetDestX_logical = (Math.random() - 0.5) * (GOAL_WIDTH_3D / PITCH_WIDTH_3D * LOGICAL_PITCH_WIDTH * 0.3); 
                    targetDestY_logical = P1_DEFENDING_GOAL_Y; 
                    player.isSprinting = true; 

                    if (player.y > AI_SHOOTING_RANGE_Y_MIN && Math.random() < 0.25) { 
                        player.isKicking = true;
                        player.kickCharge = Math.random() * (MAX_KICK_CHARGE * 0.6 - MIN_KICK_POWER_FACTOR) + MIN_KICK_POWER_FACTOR; 
                    }
                } else { 
                    targetDestX_logical = ball.x;
                    targetDestY_logical = ball.y;
                    player.isSprinting = Math.random() < 0.55;
                    if (Math.random() < 0.1) { 
                        targetDestX_logical += (Math.random() - 0.5) * PLAYER_RADIUS_LOGICAL * 4;
                        targetDestY_logical += (Math.random() - 0.5) * PLAYER_RADIUS_LOGICAL * 4;
                    }
                }
                const angleToTarget = Math.atan2(targetDestY_logical - player.y, targetDestX_logical - player.x);
                targetDx_logical = Math.cos(angleToTarget) * actualSpeed;
                targetDy_logical = Math.sin(angleToTarget) * actualSpeed;
            }

            player.dx = player.dx * PLAYER_INERTIA + targetDx_logical * (1 - PLAYER_INERTIA);
            player.dy = player.dy * PLAYER_INERTIA + targetDy_logical * (1 - PLAYER_INERTIA);
            
            if (!isAI && player === player1 && frameCount % 180 === 0) {
                // console.log(`[P1 LOGIC DEBUG] Before Pos Update: x=${player.x.toFixed(2)}, y=${player.y.toFixed(2)}, dx=${player.dx.toFixed(2)}, dy=${player.dy.toFixed(2)}, dtFactor=${dtFactor.toFixed(3)}`);
            }

            player.x += player.dx * dtFactor; 
            player.y += player.dy * dtFactor;

            if (!isAI && player === player1 && frameCount % 180 === 0) {
                // console.log(`[P1 LOGIC DEBUG] After Pos Update: x=${player.x.toFixed(2)}, y=${player.y.toFixed(2)}`);
            }


            player.x = Math.max(-LOGICAL_PITCH_WIDTH/2 + PLAYER_RADIUS_LOGICAL, Math.min(LOGICAL_PITCH_WIDTH/2 - PLAYER_RADIUS_LOGICAL, player.x));
            player.y = Math.max(-LOGICAL_PITCH_HEIGHT/2 + PLAYER_RADIUS_LOGICAL, Math.min(LOGICAL_PITCH_HEIGHT/2 - PLAYER_RADIUS_LOGICAL, player.y));

            const playerMesh = gameMeshes[player.id];
            const pos3D = mapTo3D(player.x, player.y);
            
            // if (!isAI && player === player1 && frameCount % 180 === 0) {
            //     console.log(`[P1 LOGIC DEBUG] Mapped 3D: x=${pos3D.x.toFixed(2)}, z=${pos3D.z.toFixed(2)}. Current Mesh Pos: x=${playerMesh.position.x.toFixed(2)}, z=${playerMesh.position.z.toFixed(2)}`);
            // }
            playerMesh.position.set(pos3D.x, 0, pos3D.z); 
            // if (!isAI && player === player1 && frameCount % 180 === 0) {
            //     console.log(`[P1 LOGIC DEBUG] Mesh Pos After Set: x=${playerMesh.position.x.toFixed(2)}, z=${playerMesh.position.z.toFixed(2)}`);
            // }
            
            if (targetDx_logical !== 0 || targetDy_logical !== 0) {
                const lookAtTargetPos = mapTo3D(player.x + targetDx_logical, player.y + targetDy_logical);
                playerMesh.lookAt(lookAtTargetPos.x, playerMesh.position.y, lookAtTargetPos.z); 
                player.lastMoveAngle = Math.atan2(targetDy_logical, targetDx_logical); 
            } else if (player.lastMoveAngle !== undefined) { 
                 const lookAtTargetPos = mapTo3D(player.x + Math.cos(player.lastMoveAngle), player.y + Math.sin(player.lastMoveAngle));
                 playerMesh.lookAt(lookAtTargetPos.x, playerMesh.position.y, lookAtTargetPos.z);
            }
            
            if (player.hasBall && ball.controlledBy === player) { 
                ball.x = player.x + Math.cos(player.lastMoveAngle) * DRIBBLING_OFFSET_DISTANCE; 
                ball.y = player.y + Math.sin(player.lastMoveAngle) * DRIBBLING_OFFSET_DISTANCE; 
                ball.dx = player.dx * 0.8; ball.dy = player.dy * 0.8; 
            }
            if (player.isKicking && player.hasBall && ball.controlledBy === player) { 
                if (!isAI) console.log("[P1 KICK ACTION DEBUG] Conditions met. isKicking, hasBall, controlledBySelf are all true.");
                let kickAngle_logical = player.lastMoveAngle; 
                if (targetDx_logical === 0 && targetDy_logical === 0 || isAI) { 
                     const goalY = (player === player1) ? -LOGICAL_PITCH_HEIGHT / 2 : LOGICAL_PITCH_HEIGHT / 2;
                     kickAngle_logical = Math.atan2(goalY - player.y, 0 - player.x);
                     if(isAI) kickAngle_logical += (Math.random() - 0.5) * 0.4; 
                     if (!isAI) console.log(`[P1 KICK ACTION DEBUG] Stationary/AI kick. Angle: ${kickAngle_logical.toFixed(2)}`);
                }
                let kickPower_logical = PASS_STRENGTH + (KICK_STRENGTH - PASS_STRENGTH) * player.kickCharge;
                if (!isAI) console.log(`[P1 KICK ACTION DEBUG] Kick Power: ${kickPower_logical.toFixed(2)}, Charge: ${player.kickCharge.toFixed(2)}`);

                ball.dx = Math.cos(kickAngle_logical) * kickPower_logical;
                ball.dy = Math.sin(kickAngle_logical) * kickPower_logical;
                player.hasBall = false; ball.controlledBy = null; ball.lastTouchedBy = player; 
                if (!isAI) console.log("[P1 KICK ACTION DEBUG] Player 1 lost possession after kick.");
                player.isKicking = false; player.kickCharge = 0; 
                playSoundEffect('kickHard');
            }
            if (!player.hasBall && ball.controlledBy === null) { 
                const distToBall = distance(player.x, player.y, ball.x, ball.y); 
                // if (!isAI && frameCount % 60 === 0) console.log(`[P1 POSSESSION CHECK DEBUG] Dist to ball: ${distToBall.toFixed(1)}, Threshold: ${DRIBBLING_DISTANCE_THRESHOLD}`);
                if (distToBall < DRIBBLING_DISTANCE_THRESHOLD) { 
                    player.hasBall = true; 
                    ball.controlledBy = player; 
                    if (!isAI) console.log("[P1 POSSESSION GAINED DEBUG]");
                }
            }
        }

        function updateGoalkeeper(gk, isPlayer1GK, deltaTime) { /* ... Placeholder ... */ }
        function updateBall(deltaTime) { 
            if (!ball || !gameMeshes.ball) return;
            const dtFactor = deltaTime / (1000/60);

            if (ball.controlledBy === null) { 
                ball.x += ball.dx * dtFactor;
                ball.y += ball.dy * dtFactor;
                ball.dx *= Math.pow(BALL_INERTIA, dtFactor); 
                ball.dy *= Math.pow(BALL_INERTIA, dtFactor);
            }
            const goalMouthWidthLogical = GOAL_WIDTH_3D / PITCH_WIDTH_3D * LOGICAL_PITCH_WIDTH;
            // P2's defending goal (AI defends this, negative logical Y, P1 attacks this)
            if (ball.y < -LOGICAL_PITCH_HEIGHT / 2 + BALL_RADIUS_LOGICAL) { 
                if (Math.abs(ball.x) < goalMouthWidthLogical / 2) {
                    if (ball.y < -LOGICAL_PITCH_HEIGHT / 2) goalScored(player1); 
                } else { ball.y = -LOGICAL_PITCH_HEIGHT / 2 + BALL_RADIUS_LOGICAL; ball.dy *= -0.75; playSoundEffect('ballBounce');}
            }
            // P1's defending goal (Human defends this, positive logical Y, P2 attacks this)
            if (ball.y > LOGICAL_PITCH_HEIGHT / 2 - BALL_RADIUS_LOGICAL) { 
                if (Math.abs(ball.x) < goalMouthWidthLogical / 2) {
                    if (ball.y > LOGICAL_PITCH_HEIGHT / 2) goalScored(player2); 
                } else { ball.y = LOGICAL_PITCH_HEIGHT / 2 - BALL_RADIUS_LOGICAL; ball.dy *= -0.75; playSoundEffect('ballBounce');}
            }
            if (Math.abs(ball.x) > LOGICAL_PITCH_WIDTH / 2 - BALL_RADIUS_LOGICAL) {
                ball.x = Math.sign(ball.x) * (LOGICAL_PITCH_WIDTH / 2 - BALL_RADIUS_LOGICAL);
                ball.dx *= -0.75; playSoundEffect('ballBounce');
            }

            const pos3D = mapTo3D(ball.x, ball.y);
            gameMeshes.ball.position.set(pos3D.x, BALL_RADIUS_3D, pos3D.z); 
            const speed = Math.sqrt(ball.dx**2 + ball.dy**2);
            if (speed > 10) { 
                gameMeshes.ball.rotation.x += ball.dy * 0.0002 * speed * dtFactor; 
                gameMeshes.ball.rotation.z -= ball.dx * 0.0002 * speed * dtFactor;
            }
        }
        function handleCollisions() { 
            if (!player1 || !player2 || !ball) return;

            const pDist = distance(player1.x, player1.y, player2.x, player2.y);
            const collisionThreshold = PLAYER_RADIUS_LOGICAL * 1.8; 

            if (pDist < collisionThreshold) {
                // console.log("Player-Player Collision!");
                const angle = Math.atan2(player2.y - player1.y, player2.x - player1.x);
                const overlap = collisionThreshold - pDist;
                const moveBack = overlap / 2 * 0.7; 
                
                player1.x -= Math.cos(angle) * moveBack;
                player1.y -= Math.sin(angle) * moveBack;
                player2.x += Math.cos(angle) * moveBack;
                player2.y += Math.sin(angle) * moveBack;

                const tackleChance = 0.4; 
                if (player1.hasBall && ball.controlledBy === player1 && (player2.isSprinting || Math.random() < 0.3) ) {
                    if (Math.random() < tackleChance) {
                        console.log("[COLLISION DEBUG] P1 loses ball to P2");
                        player1.hasBall = false; ball.controlledBy = null;
                        ball.dx += (Math.random() - 0.5) * KICK_STRENGTH * 0.1; 
                        ball.dy += (Math.random() - 0.5) * KICK_STRENGTH * 0.1;
                    }
                } else if (player2.hasBall && ball.controlledBy === player2 && (player1.isSprinting || Math.random() < 0.3) ) {
                    if (Math.random() < tackleChance) {
                        console.log("[COLLISION DEBUG] P2 loses ball to P1");
                        player2.hasBall = false; ball.controlledBy = null;
                        ball.dx += (Math.random() - 0.5) * KICK_STRENGTH * 0.1;
                        ball.dy += (Math.random() - 0.5) * KICK_STRENGTH * 0.1;
                    }
                }
            }
        }
        function goalScored(scoringPlayer) { 
            if (gameState !== 'PLAYING' || !scoringPlayer) return;
            gameState = 'GOAL_SCORED'; 
            scoringPlayer.score++; 
            updateScores();
            playSoundEffect('goalCheer'); 
            showMessage("GOAL!!!", 2200, true); 
            console.log(`${scoringPlayer.teamName || scoringPlayer.id} SCORED! Score: ${player1.score} - ${player2.score}`);
        }
        
        function startGameTimer() { timeLeft = GAME_DURATION_SECONDS; updateTimerDisplay(); if (gameTimerInterval) clearInterval(gameTimerInterval); gameTimerInterval = setInterval(() => { if (gameState === 'PLAYING') { timeLeft--; updateTimerDisplay(); if (timeLeft <= 0) endGame(); } }, 1000); }
        function startGame() { if (gameState === 'PLAYING') return; resetGeminiUsage(); initAudio().then(() => { messageDisplay.classList.remove('show', 'goal-celebration'); messageDisplay.style.display = 'none'; banterDisplay.style.display = 'none'; resetPositions(true); startGameTimer(); gameState = 'READY'; playSoundEffect('whistleLong'); showMessage("KICK OFF!", 1200); setTimeout(() => { if(gameState === 'READY') gameState = 'PLAYING'; }, 1200); }).catch(err => console.error("Audio start error:", err)); }
        function endGame(winner = null) { gameState = 'GAME_OVER'; clearInterval(gameTimerInterval); playSoundEffect('whistleLong'); let msg = "TIME UP! "; let p1N = (player1 && player1.teamName) ? player1.teamName : "Team 1"; let p2N = (player2 && player2.teamName) ? player2.teamName : "Team 2"; if (winner) msg = `${winner} WINS!`; else { if (player1 && player2 && player1.score > player2.score) msg += `${p1N} WINS!`; else if (player1 && player2 && player2.score > player1.score) msg += `${p2N} WINS!`; else msg += "IT'S A DRAW!"; } msg += isTouchDevice ? "\nTap KICK for New Game" : "\nENTER for New Game"; showMessage(msg, -1); }
        
        function setupTouchControls() {
            if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                isTouchDevice = true;
                touchControlsContainer.style.display = 'flex';
                if(controlsInfoDisplay) controlsInfoDisplay.style.display = 'none';

                const joystick = document.getElementById('joystickArea');
                const nub = document.getElementById('joystickNub');
                const actionBtn = document.getElementById('kickButton');

                let joystickTouchId = null;
                let joystickCenter = { x: 0, y: 0 }; 
                let joystickRadius = 0;

                joystick.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (joystickTouchId === null) {
                        const touch = e.changedTouches[0];
                        joystickTouchId = touch.identifier;
                        const rect = joystick.getBoundingClientRect();
                        joystickCenter.x = rect.left + rect.width / 2;
                        joystickCenter.y = rect.top + rect.height / 2;
                        joystickRadius = joystick.offsetWidth / 2; 
                        touchState.joystickActive = true;
                        updateJoystickVisuals(touch.clientX, touch.clientY, nub, joystickCenter, joystickRadius);
                    }
                }, { passive: false });

                document.addEventListener('touchmove', (e) => {
                    if (joystickTouchId !== null) {
                        for (let i = 0; i < e.changedTouches.length; i++) {
                            const touch = e.changedTouches[i];
                            if (touch.identifier === joystickTouchId) {
                                e.preventDefault();
                                updateJoystickVisuals(touch.clientX, touch.clientY, nub, joystickCenter, joystickRadius);
                                break;
                            }
                        }
                    }
                }, { passive: false });

                const endJoystick = (e) => {
                     for (let i = 0; i < e.changedTouches.length; i++) {
                        if (e.changedTouches[i].identifier === joystickTouchId) {
                            joystickTouchId = null;
                            touchState.joystickActive = false;
                            touchState.joystickCurrentX = 0; 
                            touchState.joystickCurrentY = 0;
                            nub.style.left = '50%'; 
                            nub.style.top = '50%';
                            nub.style.transform = 'translate(-50%, -50%)'; 
                            break;
                        }
                    }
                };
                document.addEventListener('touchend', endJoystick);
                document.addEventListener('touchcancel', endJoystick);

                function updateJoystickVisuals(clientX, clientY, nubEl, center, radius) {
                    let deltaX = clientX - center.x;
                    let deltaY = clientY - center.y;
                    const dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    const maxDistVisual = radius - nubEl.offsetWidth / 2; 

                    if (dist > maxDistVisual) {
                        deltaX = (deltaX / dist) * maxDistVisual;
                        deltaY = (deltaY / dist) * maxDistVisual;
                    }
                    nubEl.style.left = `calc(50% + ${deltaX}px)`;
                    nubEl.style.top = `calc(50% + ${deltaY}px)`;
                    
                    touchState.joystickCurrentX = Math.max(-1, Math.min(1, (clientX - center.x) / radius));
                    touchState.joystickCurrentY = Math.max(-1, Math.min(1, (clientY - center.y) / radius));
                    // if (frameCount % 60 === 0) console.log(`[DEBUG] Joystick Logic: X=${touchState.joystickCurrentX.toFixed(2)}, Y=${touchState.joystickCurrentY.toFixed(2)}`);
                }

                actionBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault(); 
                    console.log("[DEBUG] Kick Button Touch Start");
                    if (player1) { player1.actionButtonDown = true; player1.actionButtonStartTime = performance.now(); player1.kickCharge = 0; }
                    if (gameState === 'GAME_OVER' || gameState === 'INITIAL') startGame();
                }, { passive: false });
                actionBtn.addEventListener('touchend', (e) => { 
                    e.preventDefault(); 
                    if (player1) { 
                        console.log(`[DEBUG] Kick Button Touch End. Has Ball: ${player1.hasBall}, Action Down: ${player1.actionButtonDown}`);
                        if (player1.actionButtonDown && player1.hasBall) {
                            player1.isKicking = true; 
                            console.log("[DEBUG] player1.isKicking SET TO TRUE by touch");
                        }
                        player1.actionButtonDown = false; 
                    }
                }, { passive: false });
            } else {
                if (touchControlsContainer) touchControlsContainer.style.display = 'none';
            }
        }
        
        let cameraTarget = new THREE.Vector3(); 

        function gameLoop() {
            const now = performance.now();
            const deltaTime = Math.min(32, now - (lastTime || now)); 
            lastTime = now;
            
            if (frameCount % 120 === 0) { 
                // console.log(`gameLoop - deltaTime: ${deltaTime.toFixed(2)}`);
            }

            if (gameState === 'PLAYING' || gameState === 'GOAL_SCORED' || gameState === 'READY') {
                if (player1 && player2 && ball && goalkeeper1 && goalkeeper2) { 
                    updateFieldPlayer(player1, false, deltaTime); 
                    updateFieldPlayer(player2, true, deltaTime);
                    // updateGoalkeeper(goalkeeper1, true, deltaTime); 
                    // updateGoalkeeper(goalkeeper2, false, deltaTime); 
                    updateBall(deltaTime); 
                    handleCollisions(); 
                }
            }

            if (debugCube) {
                debugCube.rotation.x += 0.01;
                debugCube.rotation.y += 0.01;
            }

            if (camera && gameMeshes.ball && gameMeshes.ball.position) {
                const ballPos3D = gameMeshes.ball.position;
                cameraTarget.lerp(ballPos3D, 0.05); 

                const camDist = PITCH_LENGTH_3D * 0.4 + 20; 
                const camHeight = PITCH_LENGTH_3D * 0.5;   

                camera.position.x = cameraTarget.x;
                camera.position.y = camHeight;
                camera.position.z = cameraTarget.z + camDist; 
                
                camera.lookAt(cameraTarget.x, 0, cameraTarget.z); 
            }


            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
            frameCount++;
            requestAnimationFrame(gameLoop);
        }

        window.addEventListener('keydown', (e) => { 
            keys[e.key.toLowerCase()] = true; 
            // if (frameCount % 60 === 0) console.log("[DEBUG] Keydown:", e.key, keys);
            if (e.key === 'Enter' && (gameState === 'GAME_OVER' || gameState === 'INITIAL')) startGame(); 
            if ((e.key === ' ' || e.key.toLowerCase() === 'k') && player1 && !player1.actionButtonDown) { 
                console.log("[DEBUG] Kick Key Down");
                player1.actionButtonDown = true; player1.actionButtonStartTime = performance.now(); player1.kickCharge = 0; 
            } 
        });
        window.addEventListener('keyup', (e) => { 
            keys[e.key.toLowerCase()] = false; 
            // if (frameCount % 60 === 0) console.log("[DEBUG] Keyup:", e.key, keys);
            if ((e.key === ' ' || e.key.toLowerCase() === 'k') && player1) { 
                console.log(`[DEBUG] Kick Key Up. Has Ball: ${player1.hasBall}, Action Down: ${player1.actionButtonDown}`);
                if (player1.actionButtonDown && player1.hasBall) { 
                    player1.isKicking = true; 
                    console.log("[DEBUG] player1.isKicking SET TO TRUE by keyup");
                } 
                player1.actionButtonDown = false; 
            } 
        });

        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOMContentLoaded: Initializing...");
            initThreeJSScene(); 
            resetPositions(true); 
            setupTouchControls(); 
            
            showMessage(isTouchDevice ? "Pixel Pitch Pro 3D\nTap KICK to Start" : "Pixel Pitch Pro 3D\nPress Enter to Start", -1);
            
            lastTime = performance.now(); 

            const muteBtn = document.getElementById('muteButton'); if (muteBtn) muteBtn.addEventListener('click', () => {isMuted = !isMuted; muteBtn.textContent = isMuted ? "Unmute" : "Mute"; if (!isMuted) initAudio().catch(err => console.error("Audio unmute error:", err));});
            if (!isMuted) initAudio().catch(err => console.warn("Initial audio start failed:", err));
            if (teamNameButton) teamNameButton.addEventListener('click', generateTeamNames);
            if (banterButton) banterButton.addEventListener('click', getGameBanter);
            console.log("DOMContentLoaded setup complete.");
        });
    </script>
</body>
</html>
